## try-with-resource에 대해서 설명해주세요.
try-with-resources는 자바 버전7에 도입된 문법입니다.

자바 7 버전 이전에서 하나 이상의 리소스(AutoCloseable을 구현한 객체 혹은 Closeable를 구현한 객체)를 사용할 경우 개발자가 임의로 finally 문에서 ~~.close()를 사용하여 자원 해제를 시켜줘야 했습니다.

만약 개발자가 사용한 자원을 finally 문에서 해제시켜주지 않고 누락시켰다면 자원이 해제되지 않은 채로 프로그램이 오작동하게 되고, finally 문에서 자원을 해제 시켜주더라도 자원 해제를 위한 중복 코드가 발생하기 때문에 소스 코드의 가독성을 해치는 단점이 있었습니다. 

이를 해결하기 위해 try() 안에 사용할 리소스 객체를 명시적으로 선언하여 사용하면, try 블록 안에서 로직이 정상적으로 완료되었는지, 갑작스럽게 완료되었는지 여부와 관계 없이 JVM에서 자동으로 자원을 반납해주는 기능을 하도록 도입하였습니다.

추가로, 자바 9 버전에서는 try() 문 안에 명시적으로 객체 선언을 하기 보다는 try 문 바깥에서 객체 선언을 하고 생성된 인스턴스의 변수를 넣어줄 수 있도록 바뀌었습니다.

- ****Closeable과 AutoCloseable의 관계**** : 
여기서 한가지 재미있는 사실이 있는데, 기존의 Closeable에 부모 인터페이스로 AutoCloesable을 추가했다는 점이다.
즉, Cloesable에 부모 인터페이스인 AutoCloesable을 새로 추가한 것이다.
상식적으로 먼저 만들어진 인터페이스를 자식 클래스나 인터페이스에 사용하는 것이 일반적일 것이다. 하지만 Java 개발자들은 먼저 만들어진 Cloesable 인터페이스에 부모 인터페이스인 AutoCloesable을 추가함으로써 하위 호환성을 100% 달성함과 동시에 변경 작업에 대한 수고를 덜었다. 만약 Cloesable을 부모로 만들었다면 기존에 만들어준 클래스들이 모두 Cloesable이 아닌 AutoCloesable를 구현(implements) 하도록 수정이 필요했을 것이다.
하지만 이러한 구조 덕분에 기존에 구현된 자원 클래스들 모두 try-with-resources가 사용가능해졌다.
## 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 정보를 알고 있는지에 대한 척도입니다.

- 강한 결합 : 구현클래스를 직접 참조하는 것을 뜻한다.
- 느슨한 결합: 구현 클래스를 직접 참조하는 강한 결합과 달리추상화에 의존한다. 
결합도의 관점에서 구체 클래스 의존에서 인터 페이스 의존으로 갈 수록 결합도가 느슨해진다.

→ 강한 결합은 코드의 유연성과 재사용성을 줄이고 변경을 어렵게 한다는 단점때문에 느슨한 결합을 지향해야한다.
## 직렬화와 역직렬화에 대해서 설명해주세요.
- Java 직렬화
    - 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술이다.
    - JVM의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술이다.
- Java 역직렬화
    - 바이트로 변환된 데이터를 다시 객체로 변환하는 기술이다.
    - 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 기술이다.

## 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
- **Synchronized키워드 명시**
    - **현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터 접근을 막아 순차적으로 데이터에 접근할 수 있도록 해줍니다.**
    - 문제점
        - 하나의 프로세스 안에서만 보장이 됩니다.
        - 즉, 서버가 1대일때는 문제가 없지만 서버가 2대 이상일 경우 데이터에 대한 접근을 막을 수가 없습니다.
- **Atomic 클래스**
    - Atomic 클래스는 CAS(compare-and-swap)를 이용하여 동시성을 하므로 여러 쓰레드에서 데이터를 write해도 문제가 없습니다. synchronized 보다 적은 비용으로 동시성을 보장할 수 있습니다.
    - CAS 알고리즘이란 현재 스레드가 존재하는 CPU의 CacheMemory와 MainMemory에 저장된 값을 비교하여, 일치하는 경우 새로운 값으로 교체하고, 일치하지 않을 경우 기존 교체가 실패되고, 이에 대해 계속 재시도하는 방식입니다.
    - CPU가 MainMemory의 자원을 CPU Cache Memory로 가져와 연산을 수행하는 동안 다른 스레드에서 연산이 수행되어 MainMemory의 자원 값이 바뀌었을 경우 기존 연산을 실패처리하고, 새로 바뀐 MainMemory 값으로 재수행하는 방식입니다.
- **Lock클래스**
    - synchronized블럭으로 동기화하면 자동적으로 lock이 걸리고 풀려서 편하나, 같은 메서드 내에서만 lock을 걸 수 있다는 제약이 있다. 이럴 때 lock 클래스를 사용한다.
- **비관적 락(DB)**
    - **동시성문제가 발생할 것이라고 예상하고 락**을 걸어버리는 방식입니다.
    - **장점**
        - **충돌이 자주 발생하는 환경**에 대해서는 롤백의 횟수를 줄일 수 있으므로 성능에서 유리합니다.
        - 데이터 무결성을 보장하는 수준이 매우 높습니다.
    - **단점**
        - 데이터 자체에 락을 걸어버리므로 **동시성이 떨어져** 성능 손해를 많이 보게 됩니다. 특히 읽기가 많이 이루어지는 데이터베이스의 경우에는 손해가 더 두드러집니다.
        - 서로 자원이 필요한 경우에, 락이 걸려있으므로 **데드락**이 일어날 가능성이 있습니다.
- **낙관적 락(DB)**
    - 실제로 Lock 을 이용하지 않고 **버전**을 이용함으로써 정합성을 맞추는 방법입니다.
    - DB가 아닌 application level에서 잡아주는 lock이다
    - **장점**
        - 충돌이 안난다는 가정하에, **동시 요청**에 대해서 처리 성능이 좋습니다.
    - **단점**
        - 잦은 충돌이 일어나는경우 **롤백처리**에 대한 비용이 많이 들어 오히려 성능에서 손해를 볼 수 있습니다.
        - 롤백 처리를 **구현**하는게 복잡할 수 있습니다.

## Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
정리하면 Mutable은 **객체의 수정을 허용**하나, Immutable인 경우 **객체의 수정을 허용하지 않는다**
Mutable 객체는 도메인 개체(도메인 클래스 혹은 엔터티)로 사용됩니다.
Immutable 객체는  값 객체, 서비스 객체 등에 사용됩니다
또한 Immutable 객체의 변경 메서드는 변경한 객체의 복사본을 반환해야 한다는 특징이 있습니다.

동시성 문제때문에 immutable객체를 더 지양합니다 

### 불변객체의 장단점

- 장점
    - Thread-safe하여 멀티스레드 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
- 단점
    - 객체의 값이 할당될 때마다 새로운 객체가 필요하다 따라서 메모리 누수와 성능저하를 발생시킬 수 있다
- mutable한 객체를 immutable한 객체로 사용하기
    방어적 복사, setter메서드 제거, final키워드 사용하기, 모든 클래스 변수를 private과 final로 사용하기
## 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
1. Assertion을 사용하기 
    자바 4부터 새롭게 추가되었고, 개발자가 의도한 특정코드나 조건, 변수값을 먼저 검증 검사할때 사용한다. 
    (주의할 점으로는 compile에서는 실행되지 않아 별도의 옵션을 주어야 하고 public메서드의 파라미터를 검사하는 경우 에는 사용하면안된다. → exception을 발생시키는게 맞다)
    
2. Objects util클래스 사용하기 
3. Optional 사용하기

