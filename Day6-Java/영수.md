## 기본질문

## try-with-resource에 대해서 설명해주세요.
try-with-resources는 자바 버전7에 도입된 Auth Closeable을 구현한 객체를 자원을 자동 해제해주는 문법입니다. 

try() 괄호 안에 사용할 리소스 객체를 명시적으로 선언하여 사용하면, 정상완료인지 상관 없이 JVM에서 자동으로 자원을 반납해줍니다.  

자바9에서는 객체선언을하고 인스턴스의 변수만 넣어도 자원을 해제해줍니다. 

이전에는 finally 문에서 ~~.close()를 사용하여 자원 해제를 시켜줘야 했으나 try-catch-finally를 쓰면 에러 트레이스가 누락이 될 수 있어 예외의 원인을 찾기 힘든 문제가 있습니다. finally 블록에서 예외가 발생하면, 해당 예외가 try-catch 블록 바깥으로 전달되지 않으며, 대신에 이전에 발생한 예외가 전달됩니다. 

반면 try-with-resources는 예외가 누락없이 Java 파일이 Class 파일로 컴파일 될 때 try-with-resources에서 누락없이 모든 경우를 try-catch-finally로 변환해주기 때문입니다. 

특징으로는, 오토 클로즈에이블이 추가될 때 기존 클로즈에이블 인터페이스의 하위 인터페이스가 아닌 상위 인터페이스로 추가되었는데 이는 하위버전과의 호환성을 위해 상위 인터페이스로 추가되었습니다
## 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
객체지향 관점에서 결합도는 의존성의 정도를 나타내며 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타냅니다. 

어떤 모듈이 다른 모듈에 너무 자세한 부분(구현 세부사항)까지 알고 있을 경우에 강한 결합도를 가진다고 하며, 세부사항이 아닌 추상화된 고수준 정책 (인터페이스)만 알고 있다면 낮은 결합도를 가진다고 합니다. 

강한 결합은 하나의 클래스나 모듈이 다른 클래스나 모듈에 대해 직접적으로 의존하는 상황을 말합니다. 예를 들면 추상화된 인터페이스 보다 구현체 자체를 의존하는 경우가 이에 해당합니다. 

이 경우, 클래스나 모듈의 변경이 다른 클래스나 모듈에 영향을 미치는 경우가 많아 유지보수가 어렵고 코드의 재사용성이 낮아집니다.

반면에, 느슨한 결합은 클래스나 모듈 간의 의존성을 최소화하여, 하나의 클래스나 모듈의 변경이 다른 클래스나 모듈에 영향을 미치지 않도록 하는 상황을 말합니다. 즉, 클래스나 모듈 간의 인터페이스를 통해 의존성을 처리하고, 내부 구현은 외부에서 알 수 없도록 캡슐화하여 변경에 대한 영향을 최소화합니다. 

또한, 느슨한 결합은 다형성(Polymorphism)과도 밀접한 관련이 있습니다. 다형성은 상속이나 인터페이스 등을 통해 객체의 형식을 일반화하고, 일반화된 객체를 사용하여 유연하고 확장성 있는 코드를 작성하는 것을 말합니다. 느슨한 결합을 사용하면 인터페이스를 통해 다형성을 구현할 수 있으며, 이는 코드의 확장성과 유연성, 유지보수성 코드의 재사용성 높이는 데 큰 도움이 됩니다.

이러한 관점에서 강한 결합도는 반드시 지양해야 하며, 개발자는 적절한 결합도를 유지할 수 있도록 고민하고 설계해야 합니다.
## 직렬화와 역직렬화에 대해서 설명해주세요.
직렬화란 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 스트림 형태로 데이터 변환하는 기술을 의미합니다.  저장하거나 전송하는 용도로 사용될 수 있습니다.

바이트로 변환된 데이터나 객체로 다시 변환하는 기술을 역직렬화 라고 합니다. 

이는 저장된 데이터를 읽거나 전송된 데이터를 수신할 때 사용됩니다.

자바 직렬화는 JVM의 메모리에서만 상주되어있는 객체 데이터를 영속화(Persistence)가 필요할 때 사용됩니다. 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송이 가능합니다.

자바에서의 직렬화는 ObjectOutPutStream 클래스를 이용합니다. 보안상의 이슈와 성능때문에 잘 이용하지 않습니다. 

바이너리직렬화도 있는데 디버깅이 어렵고 호환성 문제 때문에 잘 사용하지 않습니다.  

제이슨직렬화는 Jackson, Gson 등의 라이브러리를 이용하여 직렬화 하고 자주 사용합니다.
## 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
공유 자원에 대한 동시성 이슈는 크게 다음과 같은 문제를 발생시킬 수 있습니다.

1. 경쟁 상태(Race Condition) : 여러 스레드가 동시에 공유 자원에 접근할 때, 실행 순서에 따라 예상치 못한 결과가 발생하는 현상입니다.
2. 교착 상태(Deadlock) : 두 개 이상의 스레드가 서로 상대방이 가지고 있는 자원을 점유하고 기다리는 상황에서 무한 대기 상태에 빠지는 것입니다.
3. Starvation : 특정 스레드가 자원을 점유하고 다른 스레드가 접근할 수 없는 상태가 되는 것입니다.

이러한 문제를 해결하기 위해서는 다음과 같은 방법을 고려할 수 있습니다.

1. 동기화(Synchronization) : 자바에서는 synchronized 키워드를 사용하여 동기화를 구현할 수 있습니다. synchronized 메소드는 한 번에 한 스레드만 접근할 수 있으며, synchronized 블록을 사용하여 일부 코드 영역만 동기화할 수도 있습니다.
2. 락(Lock) : 자바에서는 ReentrantLock 클래스와 같은 락(Lock)을 사용하여 공유 자원에 대한 접근을 제어할 수 있습니다. 락을 얻은 스레드만 해당 자원에 접근할 수 있으며, 락을 가진 스레드가 락을 반납할 때까지 다른 스레드는 대기합니다.
3. 원자성(Atomicity) : 자바에서는 java.util.concurrent.atomic 패키지에 있는 원자적 연산 클래스를 사용하여, 여러 작업이 원자적으로 실행되도록 보장할 수 있습니다. 원자적 연산 클래스는 여러 스레드가 동시에 접근할 수 있는 변수를 원자적으로 변경할 수 있도록 지원합니다.
4. 스레드 안전(Thread Safety) : 자바에서는 스레드 안전한 코드를 작성하는 방법으로, 공유 자원에 대한 접근을 제어하고, 동기화를 적절하게 사용하는 것입니다. 이를 위해 synchronized 키워드, 락(Lock), 원자적 연산 클래스 등을 사용하여 코드를 작성할 수 있습니다.
5. 경쟁 조건(Race Condition) 제거 : 자바에서는 공유 자원에 대한 접근을 줄이거나 없애는 방법으로 문제를 해결할 수 있습니다. 이를 위해 불변 객체(Immutable Object)를 사용하거나, 스레드 로컬 변수(Thread Local Variable)를 사용하는 방법 등이 있습니다.
6. 교착 상태(Deadlock) 예방 : 자바에서는 교착 상태를 예방하기 위해, 데드락이 발생하지 않도록 자원에 대한 접근 순서를 조정하는 방법을 사용할 수 있습니다. 또한, 자바에서는 Lock 인터페이스를 사용하여 락을 해제할 수 있는 tryLock() 메소드를 제공하므로, 데드락이 발생할 가능성을 줄일 수 있습니다.
## Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
Mutable 객체는 변경 가능 객체이고, Immutable 객체는 불변 객체라고 흔히들 말합니다.

Mutable 객체는 메서드 파라미터로 넘어오면 내부적으로 파라미터를 변경할 수 있다.

Mutable 객체는 상태가 변경 가능하기 때문에, 멀티스레드 환경에서 동기화 문제를 일으킬 수 있지만, 

Immutable 객체는 변경 불가능하기 때문에, 멀티스레드 환경에서 안전하게 사용될 수 있습니다. 여러 스레드가 동시에 Immutable Collection에 접근하더라도, 객체의 내부 상태가 변경되지 않으므로 동기화에 대한 비용을 줄일 수 있습니다.

또한 불변 객체는 캐시(Caching)에 적합합니다. 

Immutable 객체는 변경이 불가능하기 때문에, 한 번 생성된 객체는 재사용될 수 있습니다. 이러한 특성은 캐시에 적합하며, 캐시를 구현할 때 유용하게 사용됩니다.

Spring에서는 이러한 이유로 Immutable 객체를 사용하여 안정적이고 안전한 코드를 구현하도록 권장하고 있습니다. 예를 들어, Spring에서는 요청(Request)과 응답(Response) 객체를 Immutable으로 구현하며, 멀티스레드 환경에서 안전하고 캐시를 활용할 수 있도록 설계하고 있습니다
## 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
1. 객체 참조 변수에 대한 null체크를 먼저 해서 null에 대해서 안전하게 다룰 순 있지만 코드량이 늘어나며 가독성이 떨어집니다.
2. primitive 타입 사용 : primitive 타입은 null을 참조하지 못합니다
3. Optional클래스 사용 : Optional 클래스는 null이 될 수 있는 객체를 감싸서 처리할 수 있습니다 
4. 컬렉션 사용시 null 반환 대신 empty 컬렉션을 반환하도록 한다.
