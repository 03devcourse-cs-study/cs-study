## JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요 
### **영속성 컨텍스트(Persistence Context)**

**Entity를 영구적으로 저장하는 환경**을 의미합니다.
 영속성 컨텍스트는 애플리케이션과 DB 사이에서 객체를 보관하는 가상의 DB 역할을 한다. 엔티티 매니저(EntityManager)를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리하게 된다.

**영속성 컨텍스트에 엔티티를 저장**하면 **트랜잭션을 커밋**하는 순간 데이터베이스에 반영합니다.
### **영속성 컨텍스트 이점**

1. **1차 캐시**: **조회가 가능하며 1차 캐시에 없으면 DB에서 조회하여 1차 캐시에 올려 놓습니다**.**영속성 컨텍스트**는 **내부에 Map 형태로 된 1차 캐시**를 가지고 있습니다. 
key: @Id로 선언한 필드, 데이터베이스의 기본키와 매핑
value: 엔티티 인스턴스
2. 영속 엔티티 **동일성 보장**: 동일성 비교가 가능합니다. **(==)**
    - 동일성과 동등성
        
        동일성 비교 : 실제 인스턴스가 같다. (==) 을 사용해 비교한다.
        
        동등성 비교 : 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다.equals() 메소드를 사용해서 비교한다.
        
3. **쓰기 지연(Transaction write-behind)**: **트랜잭션을 지원하는 쓰기 지연이 가능**하며 **트탠잭션 커밋하기 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있습니다. (네트워크 비용 절감)**
4. **변경 감지(Dirty Checking)**: **1차 캐시에 들어온 데이터를 찍습니다 (이를 스냅샷이라 합니다)**. **commit 되는 시점**에 **Entity와 스냅샷을 비교하여 update SQL을 생성**합니다.
5. **지연 로딩**: **엔티티에서 연관 엔티티를 불러올 때 그 때 SQL을 날려 해당 데이터를 가져옵니다**.

## JPA Progagation전파단계를 설명해주세요 
### 트랜잭션 전파란

트랜잭션 전파는 어떤 트랜잭션이 동작중인 과정에서 다른 트랜잭션을 실행할 경우 '어떻게 처리하는가'에 대한 개념입니다.

| 속성 |  |
| --- | --- |
| REQUIRED | 트랜잭션이 존재하는 경우 해당 트랜잭션을 그대로 사용하고, 트랜잭션이 없는 경우 트랜잭션을 생성한다.
즉 만약 트랜잭션을 중첩해서 사용한다면 내부의 트랜잭션이 따로 생성되는 것이 아니라, 외부의 트랜잭션에 그대로 껴가지고 트랜잭션을 하나만 사용하게 되는 것이다.
(기본값이다.)
예외가 발생하면 롤백이 되고 호출한 곳에도 롤백이 전파된다. |
| SUPPORTS | 트랜잭션이 존재하는 경우 해당 트랜잭션을 사용하고, 트랜잭션이 없다면 트랜잭션 없이 실행한다. |
| MANDATORY | 트랜잭션이 반드시 있어야 한다는 의미이다.
트랜잭션이 존재하는 경우 해당 트랜잭션을 사용하고, 트랜잭션이 없다면 예외를 발생시킨다. |
| REQUIRES_NEW | 트랜잭션이 존재하는 경우 트랜잭션을 잠시 보류시키고, 신규 트랜잭션을 생성하여 사용한다.
부모 트랙잭션이 롤백된다 하더라도 자식 트랜잭션은 롤백되지 않는다.
자식 트랜잭션이 롤백된다 하더라도 하더라도 부모 트랜잭션은 롤백되지 않는다.
(그러나 자식 트랜잭션에서 발생한 예외가 부모 트랜잭션에서 catch되지 않고 같이 던져지는 경우에는 두 트랜잭션 모두 롤백된다) |
| NOT_SUPPORTED | 트랜잭션이 존재하는 경우 트랜잭션을 잠시 보류시키고, 트랜잭션이 없는 상태로 처리를 수행한다. |
| NEVER | 트랜잭션이 존재하는 경우 예외를 발생시키고, 트랜잭션이 없는 상태로 처리를 수행한다. |
| NESTED | 트랜잭션이 존재할 경우 중첩된 트랜잭션을 생성하여 처리를 수행하고, 존재하지 않는다면 REQUIRED와 동일하게 동작한다. |

## JPA를 쓴다면 그 이유에 대해서 설명해주세요 
반복적인 CRUD SQL을 작성하지 않아도 되며 객체 모델링과 관계형 데이터베이스 사이의 차이점을 해결해준다

조회된 결과의 객체 매핑을 자동으로 처리해주기 때문에 코드의 양을 많이 줄일수 있으며 
애플리케이션을 SQL중심이 아닌 객체 중심으로 개발하여 생산성과 유지보수가 좋아진다.

- jpa의 단점
    - 성능 저하 위험
        - 객체 간의 매핑 설계를 잠롯했을 때 성능 저하가 발생할 수 있으며, 자동으로 생성되는 쿼리가 많기 때문에 개발자가 의도하지 않는 쿼리로 인해 성능이 저하되기도 한다.
    - 학습 시간
        - JPA를 제대로 사용하려면 알아야 할 것이 많아서 학습하는 데 시간이 오래 걸린다.

## N + 1 문제는 무엇이고 이것이 발생하는 이유와 이를 해결하는 방법을 설명해주세요.
***1***번의 쿼리를 날렸을 때 의도하지 않은 ***N***번의 쿼리가 추가적으로 실행되는 것을 의미한다

### 발생하는 이유

- JPA Fetch 전략이 EAGER 전략으로 데이터를 조회하는 경우
- JPA Fetch 전략이 LAZY 전략으로 데이터를 가져온 이후에 연관 관계인 하위 엔티티를 다시 조회하는 경우

**Why 왜 발생하는가?**

- JPA Repository로 find 시 실행하는 첫 쿼리에서 하위 엔티티까지 한 번에 가져오지 않고, 하위 엔티티를 사용할 때 추가로 조회하기 때문에.
- JPQL은 기본적으로 글로벌 Fetch 전략을 무시하고 JPQL만 가지고 SQL을 생성하기 때문에.
- 즉시 로딩에서 발생하는 이유는 JPQL을 사용하는 경우 전체 조회를 했을 때, 영속성 컨텍스트가 아닌 데이터베이스에서 직접 데이터를 조회한 다음 즉시로딩 전략이 동작하기 때문입니다.

### 해결방법

- fetch join사용
- @EntityGraph사용
- @BatchSize를 사용해 조절


