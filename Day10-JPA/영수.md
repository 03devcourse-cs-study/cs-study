## JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.
영속성 컨텍스트는 엔티티를 영구 저장하는 환경을 의미합니다.

영속성 컨텍스트를 쓰는 이유는 1차 캐시, 동일성 보장, 쓰기 지연, 변경감지(Dirty checking), 지연로딩이 있습니다.

- 1차 캐시: 조회가 가능하며 1차 캐시에 없으면 DB에서 조회하여 1차 캐시에 올려 놓습니다. 1차 캐시를 이용하면 같은 엔티티를 조회할 때 매번 데이터베이스에 접근하지 않아도 되므로 성능 향상에 도움을 줍니다.
- 동일성 보장: JPA에서는 동일한 엔티티 객체가 같은 영속성 컨텍스트에서 유지됩니다 동일성 비교가 가능합니다.(==) 이를 통해 엔티티의 동일성을 보장할 수 있습니다.
- 쓰기 지연: 트랜잭션을 지원하는 쓰기 지연이 가능하며 트랜잭션 커밋하기 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있습니다. 여러 개의 변경 사항을 하나의 트랜잭션으로 묶어서 처리할 수 있습니다.
- 변경 감지(Dirty checking): 스냅샷을 1차 캐시에 들어온 데이터를 찍습니다. commit 되는 시점에 Entity와 스냅샷과 비교하여 update SQL을 생성합니다.
- 지연 로딩: 실제 필요한 시점에 SQL을 날려 연관 엔티티를 조회하는 방식을 말합니다. 이를 통해, 연관 엔티티가 매우 많은 경우에도 성능 문제를 방지할 수 있습니다.
## JPA Propagation 전파단계를 설명해주세요
PA Propagation은 트랜잭션 동작 도중 다른 트랜잭션을 호출(실행)하는 상황에 선택할 수 있는 옵션입니다.

@Transactional의 propagation 속성을 통해 피호출 트랜잭션의 입장에서는 호출한 쪽의 트랜잭션을 그대로 사용할 수도 있고, 새롭게 트랜잭션을 생성할 수도 있습니다.

REQUIRED(디폴트): 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성합니다.

1. REQUIRED
REQUIRED 전파 단계는 이미 시작된 트랜잭션이 있다면 해당 트랜잭션에 참여하고, 그렇지 않은 경우 새로운 트랜잭션을 시작합니다. 이렇게 함으로써, 같은 트랜잭션 내에서 여러 메소드를 호출할 때 일관성 있는 데이터베이스 처리를 할 수 있습니다.
2. REQUIRES_NEW
REQUIRES_NEW 전파 단계는 항상 새로운 트랜잭션을 시작합니다. 즉, 이미 시작된 트랜잭션이 있어도 새로운 트랜잭션을 시작합니다. 이렇게 함으로써, 메소드 간에 독립적인 트랜잭션 처리를 할 수 있습니다.
3. SUPPORTS
SUPPORTS 전파 단계는 이미 시작된 트랜잭션이 있다면 해당 트랜잭션에 참여하고, 그렇지 않은 경우 트랜잭션 없이 메소드를 실행합니다. 이렇게 함으로써, 트랜잭션 처리를 할 수 있지만, 트랜잭션 처리가 필수적이지 않은 경우에 사용합니다.
4. NOT_SUPPORTED
NOT_SUPPORTED 전파 단계는 트랜잭션 없이 메소드를 실행합니다. 이미 시작된 트랜잭션이 있다면 일시 중지하고, 메소드 실행이 끝난 후 다시 시작합니다. 이렇게 함으로써, 트랜잭션 처리가 필요하지 않은 경우에 사용합니다.
5. MANDATORY
MANDATORY 전파 단계는 이미 시작된 트랜잭션이 있다면 해당 트랜잭션에 참여하고, 그렇지 않은 경우 예외를 발생시킵니다. 이렇게 함으로써, 트랜잭션 처리가 반드시 필요한 경우에 사용합니다.
6. NEVER
NEVER 전파 단계는 트랜잭션 처리를 할 수 없습니다. 이미 시작된 트랜잭션이 있다면 예외를 발생시킵니다. 이렇게 함으로써, 트랜잭션 처리가 절대적으로 필요하지 않은 경우에 사용합니다.
## JPA를 쓴다면 그 이유에 대해서 설명해주세요.
제가 JPA를 사용하는 이유는 객체지향 프레임워크이기 때문입니다. JPA를 사용하면 비즈니스 로직이 RDBMS에 의존하는 것이 아니라, 자바 코드로 표현될 수 있기 때문입니다. 그로 인해서 생산성이 높아진다고 볼 수 있습니다.(이는 JPA에 익숙하다는 것을 전제로 합니다.)

또, JPA는 JPQL로 SQL을 추상화하기 때문에 RDBMS Vendor에 관계없이 동일한 쿼리를 작성해서 같은 동작을 기대할 수 있다는 장점도 가지고 있습니다. 이는 database dialect를 지원하기 때문에 가지는 장점입니다.

1. 객체와 관계형 데이터베이스 간의 매핑 지원
JPA는 객체 지향 프로그래밍과 관계형 데이터베이스 간의 매핑을 지원합니다. 객체와 테이블 간의 매핑을 직접 구현할 필요 없이, 애노테이션을 이용해서 간단하게 매핑을 설정할 수 있습니다.
2. 생산성 향상
JPA는 ORM(Object-Relational Mapping) 기술을 사용하기 때문에, 개발자가 직접 SQL 쿼리를 작성하지 않아도 됩니다. 이를 통해 개발자는 SQL을 작성하고, 데이터베이스와의 연동에 대한 처리를 구현하는 데 드는 시간과 비용을 줄일 수 있습니다.
3. 유지보수성 향상
JPA를 사용하면 객체 간의 관계를 쉽게 표현할 수 있기 때문에, 객체 지향적인 설계를 쉽게 유지할 수 있습니다. 또한, 데이터베이스 스키마가 변경되어도 JPA가 자동으로 매핑 정보를 갱신하기 때문에, 유지보수성이 향상됩니다.
4. 데이터베이스 독립성
JPA는 데이터베이스와의 연동을 추상화한 인터페이스를 제공합니다. 따라서, 데이터베이스 종류에 상관없이 동일한 코드를 사용할 수 있습니다. 이를 통해, 데이터베이스에 종속되지 않고, 데이터베이스 독립성을 확보할 수 있습니다.
5. 성능 향상
JPA는 영속성 컨텍스트를 제공하여, 엔티티의 변경 사항을 추적하고, 트랜잭션 처리를 지원합니다. 이를 통해, 1차 캐시와 지연 로딩 등의 기능을 사용하여, 데이터베이스 연동의 성능을 향상시킬 수 있습니다.
6. 표준 인터페이스
JPA는 Java Persistence API의 표준 인터페이스를 제공합니다. 따라서, JPA를 사용하면 다른 ORM 프레임워크를 사용했을 때 발생할 수 있는 호환성 문제를 줄일 수 있습니다.
## N + 1 문제는 무엇이고 이것이 발생하는 이유와 이를 해결하는 방법을 설명해주세요.
조회된 엔티티에서 같이 조회하지 않은 연관 엔티티를 사용할 때마다 의도적이지 않은 추가적인 쿼리가 발생하게 되어, 성능 문제를 발생시킵니다.

N + 1 쿼리 문제는 즉시 로딩과 지연 로딩 전략 각각의 상황에서 발생할 수 있습니다 

해결방법

1. 이거 로딩 : 연관된 엔티티를 즉시 조회하는 방식입니다. 따라서, 한 번의 쿼리로 모든 엔티티를 조회할 수 있어, N+1 문제를 해결할 수 있습니다. 하지만, 모든 경우에 Eager Loading을 사용할 수는 없으며, 연관 엔티티가 많은 경우에는 오히려 더 많은 쿼리가 발생할 수 있기 때문에 주의가 필요합니다.
2. Fetch Join : Fetch Join은 JPQL에서 사용하는 방식으로, 연관된 엔티티를 즉시 조회하는 방식입니다. 따라서, N+1 문제를 해결할 수 있습니다. 하지만, Fetch Join은 다른 조인 방식과 달리 데이터 중복이 발생할 수 있기 때문에, 주의가 필요합니다.
3. @`EntityGraph` 를 이용하기
4. Batch Size를 이용해서 조절하거나 전역적인 Batch-size를 설정하는 방법이 있습니다 
5. DTO 사용
DTO(Data Transfer Object)는 엔티티에서 필요한 필드만 선택하여 조회하는 방식입니다. 이를 통해, 엔티티의 모든 필드를 조회하지 않고, 필요한 필드만 조회하여 N+1 문제를 해결할 수 있습니다.
