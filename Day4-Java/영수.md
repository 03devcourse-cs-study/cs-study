### 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되고 abstract로 정의된 경우이며, 인터페이스는 interface로 선언되고 모든 메소드가 추상 메소드 혹은 default method인 경우입니다. 

하는일은 비슷합니다. 상속 혹은 구현하는 클래스가 추상 메소드를 구현하도록 강제합니다.

추상클래스는 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용합니다. 단일 상속만 가능합니다. 추상클래스를 상속하는 집합간에는 연관관계가 있습니다. 

인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 다중 상속이 가능합니다. 인터페이스를 구현하는 집합간에는 관계가 없을 수 있습니다.

즉 둘의 목적은 차이가 다릅니다. 

추상클래스는 상속받아서 기능을 이용하고 확장 시키는데에 있고,

인터페이스는 메서드의 구현을 강제하여 구현 객체의 같은 동작을 보장 혹은 약속하기 위해서입니다. 

추상클래스의 문제점인 단일상속과 인터페이스의 문제점인 속성인 멤버 필드를 갖지 못하는 것을 해결하기 위해 인터페이스 + 추상클래스를 조합하며 사용하기도 하며 디자인 패턴에서 많이 사용합니다.
### 클래스는 무엇이고 객체는 무엇인가요?
클래스는 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용됩니다.

객체는 식별 가능한 개체 또는 사물입니다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가집니다. 

객체 vs 인스턴스 : 선언한 변수(객체 참조변수)
### 정적(static)이란 무엇인가요?
static은 클래스 멤버라고 하며, 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리됩니다.

static 키워드를 통해 생성된 정적멤버들은 PermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있습니다.

- Metaspace : 자바8부터 도입된 JVM 메모리 영역. 클래스 메타데이터(class, interface, method, field, constant fool) 의 정보 저장. Java힙 영역이 아닌 네이티브메모리 영역에 위치.

그러나, GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재합니다. 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있습니다. 또한 전역 상태를 만들어 객체의 상태를 외부로 노출시킬 수 있어 캡슐화 위반, 정적 메서드는 인터페이스를 구현할 수 없기 때문에, 이를 사용하는 코드를 변경하거나 대체하기가 어렵고, 멀티스레드에서 동시성 문제가 발생할 수 있습니다. 그러나 읽기 전용 공통 값 공유, 유틸리티, 상수를 처리할때는 유용합니다.
### 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
boolean(1), char(unsigned 2), byte(1), short(2), int(4), long(8), float(4), double(8)

사실 JVM에 의존적이기 때문에 특정 시스템에서는 다를 수 있으며 정확한 크기라기 보다는 대략적인 크기입니다. JVM 사양에 의해 결정됩니다. 이는 자바가 다양한 플랫폼에서 일관된 동작을 제공하려는 이유입니다. 

정밀도와 범위가 중요한 경우 double을 사용하고, 메모리 사용량이나 속도가 중요한 경우 float을 사용합니다.
### 접근 제어자의 종류와 이에 대해 설명해주세요.
private, default, protected, public이 있습니다.  

private은 해당 클래스 내에서만 접근 가능하고, 

default는 해당 패키지, 

protected는 같은 패키지 내에서는 **`public`** 과 동일하게 동작하지만, 다른 패키지에서는 상속 관계에 있는 서브 클래스에서만 접근이 가능합니다.

public은 전체 영역에서 접근 가능합니다.

접근 제어자를 사용하는 이유는 외부에 보여주고 싶은 정보들을 선택적으로 제공하기 위함이고, 캡슐화를 구현하고 코드의 안정성을 높이기 위해 사용됩니다. 클래스와 메서드의 기능을 적절한 접근 제어자로 제한하여, 클래스의 내부 구현을 숨기고 외부에서의 접근을 제한함으로써 코드의 유지보수성과 확장성을 향상시킬 수 있습니다.
### 객체지향에 대해서 설명해주세요.
프로그래밍에서 복잡한 문제를 해결하기 위해 사용되는 개념으로 기존에 작성해놓은 코드를 재사용하기 위하여 노력을 하는 것이 객체지향이라고 생각합니다. 

객체지향은 클래스가 아닌 객체를 중점으로 바라보고 문제를 해결하기 위해 모든 객체가 자신의 역할과 책임을 가지고 다른 객체와 협력하는것이 중요합니다. 이것을 지키기 위해서는 객체들은 서로 독립되어 있어야한다는 특징이 있습니다.

객체지향의 장점으로 코드의 재사용성, 유지보수성, 확장성 등을 높이고, 변경 영향을 줄일 수 있고 개발자가 더 효율적으로 문제를 해결할 수있지만, 개발 난이도가 높아지고 설계 시 많은 노력과 실력이 필요합니다.

-----------
## 추가질문

- 추상 클래스의 문제점, 인터페이스의 문제점
자바에서는 단일 상속만 가능하기 때문에, 다중 상속을 지원하지 않는다는 점입니다. 따라서, 추상 클래스는 다른 클래스를 상속받을 수 없기 때문에, 클래스 계층 구조를 설계할 때 제약이 따릅니다.
추상 클래스를 상속받는 서브 클래스에서는 반드시 추상 클래스에서 선언한 메서드를 구현해야 합니다. 이는 코드 작성에 대한 제약을 부과하는 문제점이 있습니다.
인터페이스의 문제점:

인터페이스는 구현이 없는 메서드만을 가지고 있기 때문에, 모든 메서드를 구현해야 하는 문제점이 있습니다.
새로운 기능을 추가하거나 변경하려면 모든 구현체에서 메서드를 변경해야 하는데, 이는 유지보수 측면에서 어려움을 초래할 수 있습니다.
인터페이스의 메서드가 많아지면, 구현체에서 모든 메서드를 구현하기 어려워지고, 인터페이스가 복잡해지는 문제점이 있습니다.
추상 클래스와 인터페이스는 각각의 장단점이 있으며, 적절한 상황에서 적절하게 사용해야 합니다. 
일반적으로, 다중 상속이 필요하거나, 코드의 유연성과 확장성을 높이고자 할 때는 인터페이스를 사용하며, 공통된 기능을 가지는 클래스를 만들고자 할 때는 추상 클래스를 사용하는 것이 좋습니다.
- 인터페이스의 default 메서드의 필요성
인터페이스의 default 메서드는 인터페이스를 구현하는 클래스에서 메서드를 오버라이드하지 않아도 기본적인 구현을 제공할 수 있는 기능입니다. 이는 인터페이스를 수정하지 않고도 새로운 기능을 추가할 수 있도록 합니다.

default 메서드를 사용하면, 새로운 기능을 추가할 때 기존에 인터페이스를 구현하는 클래스들이 전부 수정되지 않아도 됩니다. 이는 코드의 유지보수성과 확장성을 높여줍니다.

default 메서드는 또한 다중 상속을 지원하는데, 인터페이스가 다른 인터페이스를 상속하는 경우, default 메서드를 사용하여 여러 인터페이스에서 구현한 기본 동작을 제공할 수 있습니다. 이를 통해 코드의 중복을 제거하고 유연성을 높일 수 있습니다.

default 메서드는 자바 8에서 처음 도입되었으며, 함수형 인터페이스를 구현할 때 유용하게 사용됩니다. 함수형 인터페이스는 하나의 메서드만을 가지므로, default 메서드를 사용하여 다른 기본 메서드를 제공할 수 있습니다.

하지만, default 메서드를 남용하면 인터페이스의 복잡성이 증가할 수 있으므로, 신중하게 사용해야 합니다. 또한, default 메서드가 포함된 인터페이스를 구현하는 클래스에서는 명시적으로 오버라이드하여 구현하는 것이 좋습니다.
- primitive과 Wrapper class의 차이
Primitive 타입은 자바의 기본 데이터 타입으로, boolean, byte, char, short, int, long, float, double 이 있다. 이러한 Primitive 타입은 값(value)을 직접 저장하며, 메모리 상에 스택(stack)에 저장된다.

Wrapper 클래스는 Primitive 타입을 감싸는 클래스로, Boolean, Byte, Character, Short, Integer, Long, Float, Double이 있다. Wrapper 클래스는 Primitive 타입의 값을 객체로 다루기 위해 사용된다. Wrapper 클래스의 인스턴스는 Heap 메모리에 저장된다.

따라서, Primitive 타입은 값 자체를 저장하고 Wrapper 클래스는 객체를 생성하여 값에 접근한다는 점에서 차이가 있다. 또한, Primitive 타입은 Null 값을 가질 수 없지만, Wrapper 클래스는 Null 값을 가질 수 있다. 또한, Primitive 타입은 값을 비교할 때 "==" 연산자를 사용하며, Wrapper 클래스는 "equals()" 메소드를 사용해야 한다.
- sealed 클래스란?
Java 17부터 새로 추가된 Sealed 클래스는 상속을 제한하는 기능을 제공하는 클래스입니다. Sealed 클래스는 final 클래스처럼 직접 상속될 수 없으며, 특정 클래스들만 상속할 수 있도록 제한됩니다.

Sealed 클래스의 선언 방법은 다음과 같습니다.

```java
public sealed class Animal permits Dog, Cat, Bird {
   // 클래스 내용
}
```
위의 예제에서, Animal 클래스는 sealed로 선언되어 있으며, permits 키워드를 사용하여 Dog, Cat, Bird 클래스만 Animal 클래스를 상속할 수 있도록 제한되었습니다. 이제 Animal 클래스를 상속하는 클래스는 반드시 Dog, Cat, Bird 클래스 중 하나를 상속해야 합니다.

Sealed 클래스를 사용하면 다음과 같은 이점이 있습니다.

상속을 통한 다형성을 보장하면서도 특정 클래스들만 상속할 수 있도록 제한할 수 있습니다.
패턴 매칭(Pattern Matching)을 이용한 코드 작성이 용이해집니다.
코드의 안정성을 높일 수 있습니다.
Java에서 Sealed 클래스는 새로운 기능으로 추가되었으며, 코틀린의 Sealed 클래스와는 몇 가지 차이점이 있습니다. 예를 들어, Java의 Sealed 클래스는 sealed이 아닌 클래스도 permits 키워드를 사용하여 상속을 제한할 수 있습니다. 또한, Sealed 클래스를 상속하는 클래스는 반드시 Sealed 클래스 내부에 있는 상속 가능한 클래스 중 하나를 직접 상속해야 하며, 간접 상속은 허용되지 않습니다.