13. SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
    
    SOLID는 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙으로 이뤄진 객체지향 코드 설계 시 지켜야하는 5가지 원칙입니다. 이를 지키면 유지보수와 확장이 쉬운 코드를 작성할 수 있습니다.
    
    S(단일 책임원칙)는 한 클래스는 하나의 책임만을 가져야한다는 의미입니다. 즉, 클래스가 가지는 책임이 하나 뿐이라 해당 기능을 수정하기 위해서는 하나의 클래스만 수정하면 됩니다.
    
    O(개방 폐쇄원칙)는 요구사항이 변함에 따라 새로운 기능의 확장은 할 수 있지만 기존 코드를 수정하지 않는 것을 의미합니다. 추상화를 통해 변하지 않는 것에 의존하고 구현체만 추가하여 개발하면 됩니다.
    
    L(리스코프 치환원칙)는 클라이언트는 상위 타입의 객체가 하위 타입의 객체로 변경되어도 상위 타입의 메서드로 문제없이 동작해야한다는 의미입니다. 
    
    I(인터페이스 분리원칙)는 클라이언트의 목적에 맞는 인터페이스만 제공하는 것입니다. 모든 인터페이스를 제공하는 것이 아니라 클라이언트가 꼭 필요로 하는 부분만 인터페이스를 통해 제공하고 사용하지 않는 부분은 인터페이스를 제공하지 않습니다.
    
    D(의존역전 원칙)는 클라이언트는 변하는 하위 클래스에 의존하지 않고 변하지 않는 상위 클래스에 의존해야 함을 의미합니다. 상위 클래스에 의존하면 하위 클래스에 변경이 있거나 하위 클래스가 추가되더라도 클라이언트 코드는 변경하지 않아도 됩니다.
    
14. 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
    
    동일성은 객체의 주소를 비교하는 것이고 동등성은 객체의 값을 비교하는 것입니다. 모든 필드가 같더라도 두 객체의 주소는 다를 수 있습니다. Primitive Type은 객체가 아니라 주소가 필요 없으므로 ==로 비교가 가능하지만 객체의 경우 주소가 저장되기 때문에 equals()로 값비교를 해주어야합니다. 하지만, Object의 equals()는 결국 == 비교를 하고 있기 때문에 객체의 동등성 비교를 위해서는 equals() 메서드를 재정의해야합니다.
    
15. 원시타입과 참조타입의 차이에 대해 설명해주세요.
    
    원시타입은 값 그대로 스택 메모리에 저장되지만 참조타입은 힙 메모리에 객체로 생성하고 스택 메모리에는 그 주소값을 저장합니다. 참조타입의 경우 실제 값을 얻기 위해 주소를 통해 한 번 타고 들어가야하기 때문에 원시 타입보다 느립니다. 반면, 제네릭에는 참조타입만 사용할 수 있습니다. 또한, 참조타입만 NULL을 가질 수 있습니다.
    
16. String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
    
    String은 불변 타입입니다. 따라서 String에 +연산으로 추가한다해도 변경되는 것이 아닌 새로운 객체가 생성되어 할당됩니다. StringBuilder와 StringBuffer는 String의 불변을 해소하여 가변입니다. StringBuilder는 Thread-safe하지 않고 StringBuffer는 Thread-safe합니다.
    
    String은 내부적으로 버퍼를 생성해야하는 StringBuffer와 StringBuilder에 비해 생성 속도가 빠릅니다. 연산이 적은 경우에는 String을 사용하는 것이 좋습니다.
    
17. Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
    
    Exception은 CheckedException과 Unchecked Exception으로 구분됩니다. Checked Exception은 컴파일 타임에 발생하는 예외로 코드 상에서 직접 처리하거나 반환해야합니다. Unchecked Exception은 런타임에 발생하는 예외로 코드 상에서 직접 처리하거나 반환하지 않아도 됩니다. 트랜잭션 추상화에서 Checked Exception은 개발자가 처리할 수 있다고 판단하여 롤백하지 않습니다. Unchecked Exception은 개발자가 처리하지 않을 수 있기 때문에 롤백합니다.
    
18. Java8에서 추가된 기능에 대해서 설명해주세요.
    
    Java8에서는 아래와 같은 기능들이 추가되었습니다.
    
    - Functional Interface
        - 함수를 일급 객체처럼 다룰 수 있게 제공함
        - 추상 메서드를 하나만 포함하는 인터페이스
    - Lambda 표현식
        - 메서드로 전달할 수 있는 익명 함수를 단순화하여 표현한 것
    - Stream
        - 컬렉션, 배열에 저장된 요소들을 하나씩 참조하면서 코드를 실행하는 기능
        - for문을 사용하지 않고 람다식을 사용할 수 있어서 간결하고 가독성 좋은 코드 작성 가능
        - 재사용할 수 없고 원본 값을 변경하지 않습니다.
        - 중개연산과 종료연산으로 이루어지며 종료연산이 오기전까지 수행하지 않는다. (Lazy Evaluation)
    - Optional
        - Null을 감싸는 래퍼 클래스로 NPE의 가능성을 줄이기 위함
        - Wrapping 하는 오버헤드가 있기 때문에 null일 가능성이 없는 경우에는 사용하지 않는 것이 좋음
        - 반환 타입으로만 제한적으로 사용하자
    - 인터페이스의 Default Method
        - 인터페이스의 문제점을 개선하기 위한 것으로 기능이 추가된 경우 인터페이스에 추가하게 되면 모든 구현 클래스에서 컴파일 에러가 나는 문제를 개선
        - 구현이 된 상태로 인터페이스에 적용할 수 있어서 기존 코드를 변경하지 않고 기능을 추가할 수 있음