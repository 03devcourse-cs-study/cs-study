## 데이터베이스에서 인덱스를 사용하는 이유 및 장단점
### 인덱스를 사용하는 이유

테이블의 데이터는 순서 없이 쌓이게 되므로 특정 조건의 데이터를 찾으려면 테이블의 모든 데이터에 접근하여 비교하는 과정이 필요합니다(Full table scan) 하지만 인덱스가 있는 경우 search-key가 정렬되어 있기 때문에 조건 검색시 속도가 빠릅니다. 

만약 대량의 데이터를 가지고 있고 select~ where같은 특정 조건의 데이터를 찾을 때 인덱스를 활용하여 빠르게 데이터를 가져올 수 있습니다. 반대로 데이터의 양이 많지 않다면 굳이 인덱스를 사용할 이유가 없어집니다. 

### 인덱스의 장단점

- 장점
    - 빠른 속도 향상
- 단점
    - 추가 저장공간(약10%)
    - insert, update, delete등의 데이터 변경시 인덱스도 수정되어 추가 비용이 발생하기 때문에 성능이 저하됩니다.

## 트랜잭션에 대해서 설명해주세요
트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다. 

트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있습니다.

## ACID에 대해서 설명해주세요 
ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질입니다.

****Atomicity(원자성)****:

트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.

트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

****Consistency(일관성)****:

트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.

시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.

****Isolation(독립성,격리성)****:

둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.

수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

****Durablility(영속성,지속성)****:

성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다.

## 트랜잭션 격리수준에 대해서 설명해주세요 
트랜잭션 격리수준이란 동시에 여러 트랜잭션이 처리될 때, 특정 트랜젝션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.

### **Read Uncommitted**

**트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용**합니다. 해당 수준에서는 `Dirty Read`, `Non-Repeatable Read`, `Phantom Read`가 일어날 수 있습니다. 이 설정은 정합성에 문제가 있기 때문에 권장하는 설정은 아닙니다.

### Read Committed

**트랜잭션이 커밋되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용**합니다. 따라서 `Dirty Read`의 발생가능성을 막습니다. **커밋 되지 않은 데이터에 대해서는 실제 DB 데이터가 아닌 Undo 로그에 있는 이전 데이터를 가져오는 것입니다.** 하지만 `Non-Repeatable Read`와 `Phanton Read`에 대해서는 발생 가능성이 있습니다.

### Repeatable Read

트랜잭션내에서 삭제, 변경에 대해서 Undo 로그에 넣어두고 **앞서 발생한 트랜잭션에 대해서는 실제 데이터가 아닌 Undo 로그에 있는 백업데이터를 읽게 합니다.** 이렇게 함으로써 트랜잭션 중 값의 변경에 대해서 일정한 값으로 처리할 수 있습니다. 이렇게하면 삭제와 수정에 대해서 트랜잭션내에서 불일치를 가져오던 `Non-Reapeatable Read`를 해소할 수 있습니다.하지만 `phanton Read`문제는 여전합니다

### Serializable Read

트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않음은 물론 새로운 레코드가 나타나지도 않도록 하는 설정입니다.

## 정규화에 대해서 설명해주세요 
데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화 라고 합니다. 

- 제1 정규화
    - 제1 정규화란 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것이다.
- 제2 정규화
    - 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다. 
    여기서 완전함수 종속이라는 것은 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다.
- 제3 정규화
    - 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다. 
    여기서 이행적 종속이라는 것은 A→ B, B→ C가 성립할 때 A→ C가 성립되는 것을 의미한다.
- BCNF정규화
    - 제3정규화를 진행한 테이블에 대해 모든 결정자가 후보기카 되도록 테이블을 분해하는 것

## JOIN에 대해서 설명해주세요 
join은 데이터베이스에서 테이블간의 결합을 이야기 합니다. 자신이 검색하고 싶은 컬럼이 다른 테이블에 있을경우 주로 사용하며 여러개의 테이블을 마치 하나의 테이블인 것처럼 활용하는 방법입니다. 보통 Primary key혹은 Foreign key로 두 테이블을 연결합니다

**INNER JOIN(내부 조인)**

: 두 테이블을 조인할 때, 두 테이블에 모두 지정한 열의 데이터가 있어야 한다.

**OUTER JOIN(외부 조인)**

: 두 테이블을 조인할 때, 1개의 테이블에만 데이터가 있어도 결과가 나온다.

**CROSS JOIN(상호 조인)**

: 한쪽 테이블의 모든 행과 다른 쪽 테이블의 모든 행을 조인하는 기능이다.

**SELF JOIN(자체 조인)**

: 자신이 자신과 조인한다는 의미로, 1개의 테이블을 사용한다.
