# RDBMS vs NoSQL에 대해서 설명해주세요.

RDBMS는 데이터베이스를 이루는 객체들의 관계를 통해서 데이터를 저장하는 데이터베이스입니다. SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다.

장점으로는 명확한 데이터 구조를 보장하고, 중복을 피할 수 있습니다.

NOSQL은 RDBMS에 비해 자유로운 형태로 데이터를 저장합니다. 또한 수평확장을 할 수 있고 분산처리를 지원합니다. 다양한 형태의 NOSQL 데이터베이스가 있습니다.

둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.

### RDBMS와 NoSQL언제 사용 해야 될까?

**RDBMS**는 데이터 구조가 명확하며 변경 될 여지가 없으며 명확한 스키마가 중요한 경우 사용하는 것이 좋다. 또한 중복된 데이터가 없어(무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경되는 시스템에 적합하다.

**NoSQL**은 정확한 데이터 구조를 알 수 없고 데이터 변경/확장이 될 수 있는 경우에 좋다. 또한 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시에는 모든 컬렉션에서 수정을 해야 한다. 이러한 특징들을 기반으로 Update가 많이 이루어지지 않는 시스템이 좋다

- DB기본 개념
    - Database: 여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리하는 데이터의 집합
    - DBMS: database management System의 약자로써, 사용자와 데이터베이스 사이에서 사용자의 요청을 해석하여 데이터베이스에 저장된 정보를 관리할 수 있도록 해주는 소프트웨어
    - SQL: Structured Query Language의 약자로써, 관계형 데이터베이스 관리 시스템에 저장된 데이터를 관리하기 위해 설계된 프로그래밍 언어
    - 스키마: 데이터베이스를 구성하는 개체(Entity), 속성(Attribute), 관계(Relationship)및 제약조건등에 관해 전반적으로 정의한 메타데이터의 집합
- RDBMS란?
    
    ### RDBMS란?
    
    관계형 데이터베이스 관리 시스템이라는 뜻으로 엑셀의 형식과 유사한 2차원 테이블 형식으로 구성되며 속성과 값을 이용하여 데이터를 정의하고 저장 및 관리합니다. 
    
    각각의 속성과 값을 가진 테이블들은 서로 관계를 맺으며 존재합니다 
    
    이러한 데이터들을 활용하기 위해 사용자는 SQL이라는 언어를 활용합니다. 
    
    - 장점
        - 데이터의 분류, 정렬, 탐색 속도가 빠르다
        - SQL 이라는 구조화 된 질의를 통해 데이터를 다룰 수 있다
        - 작업의 완전성을 보장한다
        - 데이터의 UPDATE가 빠르다
    - 단점
        - 스키마 규격에 맞춰서 데이터를 다뤄야한다
        - 데이터 처리에 대한 부하 발생 시 처리가 어렵다
        - 성능향상에 높은 비용
- NoSQL이란?
    
    ### NoSQL이란?
    
    Not Only SQL의 약자로써, 관계형 데이터 베이스와 반대되는 방식을 사용하며, 데이터 및 테이블 간의 관계를 정의하지 않습니다. 
    
    따라서 정해진 스키마가 없어, 보다 자유롭게 데이터를 저장할 수 있습니다. 
    
    RDBMS로는 관리할 수 없는 복잡하고 용량이 큰 데이터들을 관리 할 수 있도록 하기위한 목적으로 등장한 개념입니다. (데이터 일관성을 포기하되 비용을 고려하여 분산하여 저장하는 scale-out을 목표로 등장) 
    
    보통 key-value형태로 저장
    
    - 장점
        - 데이터간 관계를 정의하지 않는다
        - RDBMS 보다 복잡도가 떨어져, 대용량의 데이터를 저장/관리할 수 있다
        - 테이블에 스키마가 정해져있지 않아 데이터 저장이 비교적 자유롭다
        - 많은 양의 데이터를 저장/처리할 수 있다
    - 단점
        - Key값에 대한 I/O(입출력)만 지원한다
        - 스키마가 정해져 있지 않아 데이터데 대한 규격화가 되어있지 않다
        - Data 를 UPDATE하는데 느리다
    - 다양한 형태의 NoSQL
        - key-value DB
            - 데이터가 key 와 value의 쌍으로 저장됨
            - key값은 어떠한 형태의 데이터라도 담을 수 있음. 이미지나 비디오도 가능
            - 또한 간단한 api를 지원, 질의의 속도가 빠른 편
            - Redis, Amazon Dynamo DB 등
        - Document DB
            - key와 Document의 형태로 저장
            - key-value와 다르게 value가 계층적인 형태의 도큐먼트로 저장됨 
            객체지향에서의 객체와 유사하며 이들은 하나의 단위로 취급되어 저장된다.( = 하나의 객체를 여러개의 테이블에 나눠 저장할필요가 없어짐)
            - 주요한 특징으로는 객체-관계 매핑이 필요하지 않다. 객체를 document의 형태로 바로 저장이 가능하기 때문
            - 검색에 최적화 되어있음 (key-value의 특징과 동일)
            - 사용이 번거롭고 쿼리가 SQL과 다르다는 단점이 있음
            - MongoDB, CouthDB등
        - Wide Column DB
            - Column-family Model기반의 DB
            - 이전의 모델들이 key-value값을 이용해 필드를 결정했다면 특이하게도 이 모델은 키에서 필드를 결정한다. 키는 Row(키 값) 와 Column-family, Column-name을 가진다. 연관된 데이터들은 같은 Column-family안에 속해있으며 각자의 Column-name을 가진다. 관계형 모델로 설명하자면 어트리뷰트가 계층적인 구조를 가지고 있는 셈이다. 이렇게 저장된 데이터는 하나의 커다란 테이블로 표현이 가능하며 질의는 Row, Column-family, Column-name을 통해 수행된다.
            - HBase, Hypertable등이 있다
        - Graph DB
            - 데이터를 node와 edge, property와 함께 그래프 구조를 사용하여 데이터를 표현하고 저장하는 DB.
            - 개체와 관계를 그래프 형태로 표현한 것이므로 관계형 모델이라고 할 수 있으며, 데이터 간의 관계가 탐색의 키일 경우에 적합
            - 페이스북이나 트위터같은 소셜네트워크에서 친구의 친구를 찾는 질의 등 에 적합하고 데이터를 추천해주는 추천 엔진이나 패턴 인식등의 DB로도 적합
            - Neo4J가 있다
    
    ### 어떤 상황에 사용하는가
    
    - 데이터에 대한 캐시가 필요한 경우
    - 배열 형식의 데이터를 고속으로 처리할 필요가 있는 경우
    - 정확한 데이터 구조를 알 수 없거나 변경 / 확장 될 수 있는 경우
    - 읽기(read)처리를 자주하지만, 데이터를 자주 변경(update)하지 않는 경우 (즉, 한번의 변경으로 수십 개의 문서를 업데이트 할 필요가 없는 경우)
    - 데이터베이스를 수평으로 확장해야하는 경우 ( 막대한 양의 데이터를 다뤄야 하는 경우)
    
    [RDBMS의 한계와 NoSQL을 사용하는 이유 (3) NoSQL 장단점, 특징](https://sujl95.tistory.com/83)
    

# Redis에 대해서 설명해주세요

Redis는 key-value 형식의 NOSQL DB입니다. 싱글스레드로 동작하며 여러 자료구조를 지원합니다. 그리고 다양한 용도로 사용될 수 있도록 다양한 기능을 지원합니다. 데이터의 스냅샷 혹은 AOF 로그를 통해 복구가 가능해서 어느정도 영속성도 보장됩니다.

스프링에서는 세션을 관리하거나, 캐싱을 하는데에 자주 사용됩니다.

- 캐시서버 (Cache Server)란? , Redis라는 인메모리 데이터 구조 저장소를 사용하는 이유
    
    데이터베이스는 데이터를 물리 디스크에 직접 쓰기 때문에 서버가 문제가 발생하여 다운되더라도 데이터가 손실되지 않습니다. 하지만 매번 디스크에 접근해야 하기 때문에 사용자가 많아질 수록 부하가 많아져서 느려질 수 있는데요 사용자가 많은 경우 데이터베이스가 과부화 될 수 있기 때문에 이때 캐시서버를 도입하여 사용합니다. 
    
    (이 캐시서버로 이용할 수 있는 것이 바로 Redis)
    
    캐시는 한번 읽어온 데이터를 임의의 공간에 저장하여 다음에 읽을때는 빠르게 결과값을 받을 수 있도록 도와주는 공간입니다. 
    같은 요청이 여러번 들어오는 경우 매번 데이터베이스를 거치는 것이 아니라 캐시서버에서 첫번째 요청 이후 저장된 결과값을 바로 내려주기 때문에 DB의 부하를 줄이고 서비스의 속도도 느려지지 않는 장점이 있습니다. 
    
- 캐시서버의 Look aside cache 패턴과 Write Back패턴
    
    ### **Look aside cache**
    
    1. 클라이언트가 데이터를 요청
    
    2. 웹서버는 데이터가 존재하는지 Cache 서버에 먼저 확인
    
    3. Cache 서버에 데이터가 있으면 DB에 데이터를 조회하지 않고 Cache 서버에 있는 결과값을 클라이언트에게 바로 반환 (Cache Hit)
    
    4. Cache 서버에 데이터가 없으면 DB에 데이터를 조회하여 Cache 서버에 저장하고 결과값을 클라이언트에게 반환 (Cache Miss)
    
    ### **Write Back**
    
    1. 웹서버는 모든 데이터를 Cache 서버에 저장
    
    2. Cache 서버에 특정 시간 동안 데이터가 저장됨
    
    3. Cache 서버에 있는 데이터를 DB에 저장
    
    4. DB에 저장된 Cache 서버의 데이터를 삭제
    
    - insert 쿼리를 한 번씩 500번 날리는 것보다 insert 쿼리 500개를 붙여서 한 번에 날리는 것이 더 효율적이라는 원리입니다.
    - 이 방식은 들어오는 데이터들이 저장되기 전에 메모리 공간에 머무르는데 이때 서버에 장애가 발생하여 다운된다면 데이터가 손실될 수 있다는 단점이 있습니다.
- Redis의 특징
    - Key, Value 구조이기 때문에 쿼리를 사용할 필요가 없습니다.
    - 데이터를 디스크에 쓰는 구조가 아니라 메모리에서 데이터를 처리하기 때문에 속도가 빠릅니다.
    - String, Lists, Sets, Sorted Sets, Hashes 자료 구조를 지원합니다.
        
        **String** : 가장 일반적인 key - value 구조의 형태입니다.
        
        **Sets** : String의 집합입니다. 여러 개의 값을 하나의 value에 넣을 수 있습니다. 포스트의 태깅 같은 곳에 사용될 수 있습니다.
        
        **Sorted Sets** : 중복된 데이터를 담지 않는 Set 구조에 정렬 Sort를 적용한 구조로 랭킹 보드 서버 같은 구현에 사용할 수 있습니다.
        
        **Lists** : Array 형식의 데이터 구조입니다. List를 사용하면 처음과 끝에 데이터를 넣고 빼는 건 빠르지만 중간에 데이터를 삽입하거나 삭제하는 것은 어렵습니다.
        
    - **Single Threaded** 입니다.: 한 번에 하나의 명령만 처리할 수 있습니다. 그렇기 때문에 중간에 처리 시간이 긴 명령어가 들어오면 그 뒤에 명령어들은 모두 앞에 있는 명령어가 처리될 때까지 대기가 필요합니다.(하지만 get, set 명령어의 경우 초당 10만 개 이상 처리할 수 있을 만큼 빠릅니다.)
    
- Redis 사용시 주의할 점
    - 서버에 장애가 발생했을 경우 그에 대한 운영 플랜이 꼭 필요합니다.: 인메모리 데이터 저장소의 특성상, 서버에 장애가 발생했을 경우 데이터 유실이 발생할 수 있기 때문입니다.
    - 메모리 관리가 중요합니다.
    - 싱글 스레드의 특성상, 한 번에 하나의 명령만 처리할 수 있습니다. 처리하는데 시간이 오래 걸리는 요청, 명령은 피해야 합니다.
- Redis의 백업(RDB, AOF)
    
    인메모리 데이터 저장소가 가지는 휘발성의 특성 때문에 종료되는 경우 데이터가 유실되게 됩니다. 이 단점을 Redis에서는 AOF와 RDB 라는 방식으로 백업을 하는 기능을 제공합니다.
    
    ### RDB
    
    특정한 시점의 스냅샷으로 백업하는 방식. 비교적 작은 사이즈의 파일로 백업하며 로딩속도가 빠릅니다. 그리고 단일 파일이기 때문에 원거리데이터 센터 또는 Amazon S3로 전송하기 용이합니다. 특정조건이 만족되면 현재의 Redis상태를 스냅샷으로 백업하므로 스냅샷이 찍히기 전에 Redis가 종료되면 그 사이의 데이터는 복원할 수 없습니다. 
    
    ### AOF
    
    모든 쓰기 명령에 대한 로그를 남깁니다. 
    AOF는 모든 쓰기 명령에 대해 추가하며 기록되기 때문에 파일 사이즈가 커집니다. 사이즈가 크기 때문에 서버 시작시 로딩속도가 느립니다. 용량이 특정사이즈보다 크게 되면 rewrite를 통해 사이즈를 줄입니다. 
    AOF가 활성화 되었다면 Redis의 실행시 RDB파일을 읽어오지 않고 AOF파일을 읽어옵니다. 
    
    [Redis의 백업(RDB, AOF) 알아보기](https://velog.io/@pjh612/Redis의-백업RDB-AOF-알아보기)
    

# Redis와 Memcached의 차이에 대해서 설명해주세요.

- Memcached란?
    
    무료 오픈소스이며 분산 메모리 캐싱 시스템
    데이터베이스의 부하를 줄여 동적 웹 어플리케이션의 속도개선을 위해 사용하기도 함. DB나 API호출 또는 페이지 랜더링 등으로부터 받아오는 결과 데이터를 작은 단위의 key-value 형태로 메모리에 저장하는 방식 
    
- Redis란?
    
    오픈소스로 인메모리 데이터 저장소이며 이 역시 key-value타입으로 데이터를 저장한다.  
    

Redis와 Memcached 둘 모두 오픈소스인 인메모리 데이터 저장소 입니다. 

### 공통점

1. 빠른 응답대기 시간
    
    : 데이터를 메모리에 저장하기 떄문에 디스크 기반의 DB보다 빠르게 데이터를 읽을 수 있습니다. 
    
2. 개발의 용이성
    
    : 문법적으로 사용하기 쉽고, 개발코드 양 또한 적습니다. 
    
3. 데이터 파티셔닝
    
    : 데이터를 여러 노드에 분산하여 저장시킬 수 있습니다. 따라서 수요가 증가할 때 더 많은 데이터를 효과적으로 처리하기 위하여 스케일아웃이 가능합니다. 
    
4. 다양한 프로그래밍 언어지원
    
    : 자바, 파이썬, C, C++, C#, JS, Node.js, Ruby, Go 등
    

### Memcached만의 특징

멀티스레드를 지원하기 때문에 멀티프로세스코어를 사용할 수 있습니다. 
따라서 스케일 업을 통하여 더 많은 작업처리를 할 수 있습니다. 

### Redis만의 특징

Memcached는 문자열 형태로만 저장하는 반면 Redis는 다양한 자료구조를 지원합니다 (List, Set, 정렬된 Set, Hash, Bit배열, hyperloglogs)

또한 레디스는 snapshots, AOF 로그를 통해서 데이터 복구가 가능합니다. 

- 더많은 특징
    
    # **Redis만 의 특징**
    
    ## **1. 더욱 다양한 데이터 구조**
    
    문자열 뿐만 아니라 `List`, `Set`, `정렬된 Set`, `Hash`, `Bit 배열`, `hyperloglogs` (매우 적은 메모리로 집합의 개수를 추정할 수 있는 방법)을 지원합니다. 프로그램에서 위의 다양한 자료구조를 사용할 수 있습니다. 예를 들어, `Sorted Set`을 활용하여 게임유저의 상위랭크 정보를 쉽게 제공할 수 있습니다.
    
    ## **2. Snapshots**
    
    레디스는 특정시점에 데이터를 디스크에 저장하여 파일 보관이 가능합니다. 또한, 장애상황시 복구에 사용할 수 있습니다.
    
    ## **3. 복제**
    
    `Master — Salves` 구조로, 여러개의 복제본을 만들 수 있습니다. 따라서 데이터베이스 읽기를 확장할 수 있기 때문에 높은 가용성(오랜 시간동안 고장나지 않음) 클러스터를 제공합니다
    
    ## **3. 트랜젝션**
    
    트렌젝션이란 데이터베이스 상태를 변경시키는 작업 단위를 의미하고, 원자성, 일관성, 독립성, 지속성의 특징을 가지고 있습니다. Redis는 이러한 특징을 지원합니다.
    
    ## **4. Pub / Sub messaging**
    
    Publish(발행)과 Sub(구독)방식의 메시지를 패턴 검색이 가능합니다. 따라서 높은 성능을 요구하는 채팅, 실시간 스트리밍, SNS 피드 그리고 서버상호통신에 사용할 수 있습니다.
    
    ## **5. 루아 스크립트 지원**
    
    매우 경량화된 절차스크립트 언어인 루아를 지원합니다. eval 명령어를 사용하여 루아스크립트를 실행시킬 수 있습니다. 따라서, 프로그램을 명료하게하고 성능을 높일 수 있습니다.
    
    ## **6. 위치기반 데이터 타입 지원**
    
    Redis는 실시간 위치기반데이터를 지원합니다. 따라서, 두 위치의 거리를 찾거나, 사이에 있는 요소 찾기등의 작업을 수행할 수 있습니다. 이를 활용하여 맛집, 길찾기 그리고 지도기반의 고성능 서비스를 제공할 수 있습니다.
    

### Redis의 단점

Redis는 싱글스레드이기 때문에 1번에 1개의 명령어만 실행할 수 있습니다. 따라서 저장된 모든키를 보여주는 명령어 또는 모든 데이터 삭제 등의 명령어를 사용할때 맴캐쉬드에 비해 큰 속도차이가 있습니다. 

또한 RDB(특정 간격마다 모든 데이터를 디스크에 저장)작업이 매우 오래걸립니다. 

# Elastic Search에 대해서 간단히 설명해주세요.

Elasticsearch는Apache Lucene을 기반으로 구축되어 배포된 검색 및 분석 엔진입니다. 

- ELK 스택 (=Elastic Stack)
    - **Logstash**
        - 다양한 소스( DB, csv파일 등 )의 로그 또는 트랜잭션 데이터를 수집, 집계, 파싱하여 Elasticsearch로 전달
    - **Elasticsearch**
        - Logstash로부터 받은 데이터를 검색 및 집계를 하여 필요한 관심 있는 정보를 획득
    - **Kibana**
        - Elasticsearch의 빠른 검색을 통해 데이터를 시각화 및 모니터링

### 특징

- 오픈소스이다
- 실시간 분석시스템이다
    - 하둡시스템과 달리 elasticSearch 클러스터가 실행되고 있는 동안에는 계속해서 데이터가 입력 (검색엔진에서는 색인-indexing) 되고, 그와 동시에 실시간에 가까운 (near real-time)속도로 색인된 데이터의 검색, 집계가 가능합니다.
- 전문(full text)검색 엔진
    - 루씬은 기본적으로 역색인 구조로 데이터를 저장합니다. (이런 특성을 전문 (full text)검색이라고 합니다)
    - json문서 기반 elasticSearch는 내부적으로는 역색인 구조로 데이터를 저장하고 있으나 사용자의 관점에서는 json형식으로 데이터를 전달합니다.또한 key-value형식이 아닌 문서기반으로 되어있기에 복합적인 정보를 포함하는 형식의 문서를 있는그대로 저장이 가능하며 사용자가 직관적으로 이해하고 사용할 수 있습니다. elasticsearch에서 질의에 사용되는 쿼리문이나 쿼리에 대한 결과도 모두 json형식으로 전달되고 리턴됩니다. 
    다만 json이 elasticsearch가 지원하는 유일한 형식이라 사전에 입력할 데이터를 json형식으로 가공하는 것이 필요합니다( logstash에서 변환을 지원하고 있습니다)
- Restful API
    - Elasticsearch는 Rest API를 기본으로 지원하며 모든 데이터 조회, 입력, 삭제를 http 프로토콜을 통해 Rest API로 처리합니다.
- 멀티테넌시 (multitenancy)
    - Elasticsearch의 데이터들은 인덱스(Index) 라는 논리적인 집합 단위로 구성되며 서로 다른 저장소에 분산되어 저장됩니다. 서로 다른 인덱스들을 별도의 커넥션 없이 하나의 질의로 묶어서 검색하고, 검색 결과들을 하나의 출력으로 도출할 수 있는데, Elasticsearch의 이러한 특징을 멀티테넌시 라고 합니다.

### 단점

- 트랜잭션 롤백 등의 기능을 제공하지 않는다.
    - 분산 시스템 구성의 특징때문에 시스템적으로 비용 소모가 큰 롤백, 트렌잭션을 지원하지 않는다

# Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.

elasicSearch에서는 역인덱스 형태로 데이터를 저장합니다. 
**책의 맨 뒤에 있는** 주요 키워드에 대한 내용이 몇 페이지에 있는지 볼 수 있는 **찾아보기 페이지**에 비유할 수 있습니다

반대로 RDBMS는 책에서의 목차라고 생각하면 된다. 
RDBMS 인덱스의 자료구조로는 hashTable, B-Tree, B+Tree가 있다 

- RDBMS인덱스의 자료구조
    
    **1. 해시 테이블(Hash Table)**
    
    **해시 테이블은 key와 value를 한 쌍으로 데이터를 저장하는 자료구조**이다. (key, value)로 쌍을 표현하며, key값을 이용해 대응되는 value값을 구하는 방식이다. 해시 충돌이라는 변수가 존재하지만 평균적으로 **O(1)**의 매우 빠른 시간만에 원하는 데이터를 탐색할 수 있는 구조이다.
    
    해시 테이블을 이용한다면 인덱스는 **(key, value) = (컬럼의 값, 데이터의 위치)**로 구현하는데, 해시 테이블은 실제로 인덱스에서 잘 사용되지 않는다.
    
    그 이유는, **해시 테이블은 등호(=) 연산에 최적화되어있기 때문이다.** 데이터베이스에선 부등호(<, >) 연산이 자주 사용되는데, 해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없다.
    
    **2. B+Tree**
    
    기존의 B-Tree는 어느 한 데이터의 검색은 효율적이지만, 모든 데이터를 한 번 순회하는 데에는 트리의 모든 노드를 방문해야 하므로 비효율적이다. 이러한 B-Tree의 단점을 개선시킨 자료구조가 B+Tree이다.
    
    **B-Tree 설명 : [https://rebro.kr/169](https://rebro.kr/169)**
    
    B+Tree는 **오직 leaf node에만 데이터를 저장하고 leaf node가 아닌 node에서는 자식 포인터만 저장한다.**
    
    그리고 **leaf node끼리는 Linked list로 연결되어있다.**
    
    또, B+Tree에서는 반드시 leaf node에만 데이터가 저장되기 때문에 중간 node에서 key를 올바르게 찾아가기 위해서 key가 중복될 수 있다.
    
    ![https://blog.kakaocdn.net/dn/Svp6z/btrdEi9c2DR/R4Dnmqkl8RWcqQPBACI9fK/img.png](https://blog.kakaocdn.net/dn/Svp6z/btrdEi9c2DR/R4Dnmqkl8RWcqQPBACI9fK/img.png)
    
    B-Tree 예시
    
    ![https://blog.kakaocdn.net/dn/bAARBC/btrdDydoUp7/9h4KOXBRyDNKpKDAe2ugq0/img.png](https://blog.kakaocdn.net/dn/bAARBC/btrdDydoUp7/9h4KOXBRyDNKpKDAe2ugq0/img.png)
    
    B+Tree 예시
    
    이로 인한 장점이 뭐가 있을까?
    
    **1. leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다. 따라서 하나의 node에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다.**
    
    **2. Full scan을 하는 경우 B+Tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모된다. 반면 B-Tree는 모든 node를 확인해야 한다.**
    
    반면, B-Tree의 경우 최상의 경우 특정 key를 root node에서 찾을 수 있지만, **B+Tree의 경우 반드시 특정 key에 접근하기 위해서 leaf node까지 가야 하는 단점이 있다.**
    
    인덱스에서 B-Tree 대신 주로 B+Tree를 사용하는 이유는 뭘까?
    
    해시 테이블에서 언급했듯이 **인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생할 수 있다.** 따라서 B+Tree의 Linked list를 이용하면 순차 검색을 효율적으로 할 수 있게 된다.
    
    B+Tree의 검색 과정은 B-Tree와 동일하다. 반면 B+Tree의 삽입과 삭제 과정은 약간의 차이가 있다. 기본적으로 B+Tree의 삽입과 삭제는 항상 leaf node에서 일어난다.
    
    [[DB] 11. 인덱스(Index) - (1) 개념, 장단점, B+Tree 등](https://rebro.kr/167)
    

# Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.

RDBMS는 단순 텍스트 매칭에 대한 검색만을 제공합니다 
(mysql 최신 버전에서 n-gram기반의 fulltext검색을 지원하지만 한글 검색의 경우에 아직 많이 빈약함) 
elasticsearch에서는 비정형데이터의 색인과 검색이 가능하고 형태소 분석을 통한 자연어 처리가 가능합니다 

예시를 들어 id라는 pk와 text라는 컬럼이 있을때에 text컬럼 내에 apple이라는 단어가 포함된 행들을 가져온다고 한다면 RDBMS는 text열을 한줄씩 찾아 내려가면서 포함되어있으면 가져오고 없으면 안가져오는 형식입니다. 때문에 데이터가 늘어날수록 검색해야할 대상이 늘어나기 때문에 시간도 오래걸리고 속도가 느립니다 

반면, elasticSearch는 데이터를 저장할 때 역인덱스라는 구조를 만들어 저장하므로 추출된 키워드(term) 가 가르키는 document id를 바로 얻을 수 있기때문에 데이터가 늘어나도 속도가 빠릅니다.
