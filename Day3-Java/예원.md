## JVM의 구조와 Java의 실행방식을 설명해주세요.

- java의 실행방식
    - 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환시킵니다.
    - Class Loader를 통해 class 파일들을 JVM으로 로딩합니다.
    - 로딩된 class파일들은 Execution engine을 통해 해석됩니다.
    - 해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어집니다.
- JVM의 구조
    
    ```
    
    1. 클래스 로더 시스템
        - 우리가 컴파일한 바이트코드(*.class)를 실행시점(RunTime)에 읽어들여서 메모리(Runtime Data Area)에 적절하게 배치하는 것이 클래스로더의 역할이다.
        - 크게 3가지 로딩 -> 링크 -> 초기화의 순서로 일을 한다.
           
    2. 메모리(Runtime Data Areas)
        - JVM이 프로세스로써 수행되기 위해 OS로부터 할당받는 메모리 영역이다. 목적에 따라 크게 5가지 블럭으로 나뉘어있다.
        - 메소드 영역 : 클래스 수준의 정보 (클래스 이름, 부모 클래스 이름, 메소드, 변수) 저장.
        - 힙 영역 : 객체를 저장한다. 인스턴스들이 다 힙에 저장된다.
        - 스택 영역 : 메소드가 호출될 때마다 스택 프레임이라 불리는 블럭이 하나씩 생성되고 메소드 실행이 완료되면 삭제된다.
        - PC 영역 : 쓰레드 내 현재 실행할 스택 프레임을 가리키는 포인터가 생성된다.
        - 네이티브 메소드 영역 : 다른 언어(C, C++)의 메소드 호출을 위해 할당되는 구역, 언어에 맞게 Stack이 생성된다.
    
        - 메소드 영역, 힙 영역 : 여기에 저장된 정보들은 모든 Thread 공유
        - 스택 영역, PC 영역, 네이티브 메소드 영역 : 쓰레드 마다 생성되어 저장된 정보를 공유하지 않는다.
    
    3. 실행 엔진
        - Class Loader를 통해 JVM 내의 Runtime Data Areas에 배치된 바이트코드를 명령어 단위로 읽어서 실행한다.
        - 두가지 방식의 조합을 통해 실행하는데
            - JIT 컴파일러 : 인터프리터의 단점을 보완하기 위해 도입, 위에서 설명
            - 인터프리터 : 바이트코드 명령어를 하나씩 읽어서 해석하고 실행한다. 이 과정에서 바이트코드가 네이티브 코드로 변환된다.
        - GC : 실행엔진의 제일 중요한 부분으로 더이상 참조되지 않는 객체를 모아서 정리한다.
    
    4-1. JNI(Java Native Interface)
        - 자바 애플리케이션에서 C, C++, 어셈블리로 작성된 Native 키워드를 사용한 함수를 사용할 수 있는 방법 제공
    4-2. 네이티브 메소드 라이브러리
        - C, C++로 작성 된 라이브러리
    ```
## GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
GC는 힙 영역에서 사용하지 않는 객체들을 제거하는 작업을 총칭합니다. 
이 객체를 제거하는 작업이 필요한 이유는 자바는 개발자가 메모리를 직접 해제해줄 수 없는 언어이기 때문입니다. 
따라서 객체를 사용하고 제거하는 기능이 필요하게 됩니다.

### 동작 방식

young영역과 Old영역은 서로 다른 메모리 구조로 외어있기때문에 세부적인 동작방식은 다르다. 하지만 기본적으로 가비지 컬렉션이 실행된다고 하면 다음의 2가지 공통적인 단계를 따르게 된다. 

1. stop the world
    
    Stop The World는 가비지 컬렉션을 실행하기 위해 JVM이 애플리케이션의 실행을 멈추는 작업이다. GC가 실행될 때는 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업이 중단되고, GC가 완료되면 작업이 재개된다. 
    당연히 모든 쓰레드들의 작업이 중단되면 애플리케이션이 멈추기 때문에, GC의 성능 개선을 위해 튜닝을 한다고 하면 보통 stop-the-world의 시간을 줄이는 작업을 하는 것이다. 또한 JVM에서도 이러한 문제를 해결하기 위해 다양한 실행 옵션을 제공하고 있다.
    
2. mark and sweep 
    - Mark: 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업
    - Sweep: Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업
    
    Stop The World를 통해 모든 작업을 중단시키면, GC는 스택의 모든 변수 또는 Reachable 객체를 스캔하면서 각각이 어떤 객체를 참고하고 있는지를 탐색하게 된다. 그리고 사용되고 있는 메모리를 식별하는데, 이러한 과정을 Mark라고 한다. 이후에 Mark가 되지 않은 객체들을 메모리에서 제거하는데, 이러한 과정을 Sweep라고 한다
## 컬렉션 프레임워크에 대해서 설명해주세요
자바에서 컬렉션 프레임워크(collection framework)란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미합니다
즉, 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것입니다.
이러한 컬렉션 프레임워크는 자바의 인터페이스(interface)를 사용하여 구현됩니다.
### 컬렉션 프레임 워크 종류
List, set, queue, map
## 제네릭에 대해서 설명해주세요.
제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법입니다.
이렇게 컴파일 시에 미리 타입 검사(type check)를 수행하면 다음과 같은 장점을 가집니다.

1. 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있습니다
2. 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있습니다.

JDK 1.5 이전에서는 여러 타입을 사용하는 대부분의 클래스나 메소드에서 인수나 반환값으로 Object 타입을 사용했습니다.
하지만 이 경우에는 반환된 Object 객체를 다시 원하는 타입으로 타입 변환해야 하며, 이때 오류가 발생할 가능성도 존재합니다.
하지만 JDK 1.5부터 도입된 제네릭을 사용하면 컴파일 시에 미리 타입이 정해지므로, 타입 검사나 타입 변환과 같은 번거로운 작업을 생략할 수 있게 됩니다.

### 제네릭의 특징
- 클래스 혹은 메소드에 선언할 수 있다.
- 동시에 여러 타입을 선언할 수 있다.
- 와일드 카드를 이용하여 타입에 대하여 유연한 처리를 가능케 한다.
- 제네릭 선언 및 정의시에 타입의 상속관계를 지정할 수 있다.
## 애노테이션에 대해서 설명해주세요.
애노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다. 
built-in annotation은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 애노테이션이 그 대표적인 예입니다.
## 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
오버라이딩은 상위 클래스의 메소드를 재정의 하는 것을 의미합니다. 또, 런타임 다형성이기도 합니다.
오버로딩은 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미하며 컴파일 타임 다형성이기도 합니다. 따라서 오버라이딩 될 수 있습니다.
추가로 `@Override`를 써야하는 이유는 컴파일 타임에 오버라이딩에 대한 안정성을 부여해주기 때문에 반드시 써주는 것이 좋습니다.
