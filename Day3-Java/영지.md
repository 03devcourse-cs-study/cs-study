- JVM의 구조와 Java의 실행방식을 설명해주세요.
    
    Java Virtual Machine의 줄임말로 자바를 싱행하기 위한 가상환경으로 java 코드를 기계어로 변환하고 실행하는 역할을 합니다. 
    
    Java 코드를 작성한 .java 소스파일이 컴파일러에 의해 .class 확장자를 가진 바이트코드로 변환이 됩니다. JVM이 이 바이트 코드를 운영체제에 맞는 기계어로 변환하여 실행하게 됩니다. 이때 JVM은 필요에 따라 필요에의해 메모리 관리, 스레드 관리, 예외 처리 등 작업을 수행합니다. 
    
    JVM 덕분에 java는 운영체제에 종속적이지 않게 실행이 가능합니다. 
    

- GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
    
    Garbage Collection는 JVM위에서 동작하며 사용하지 않는 메모리를 자동으로 해지해주는 기능입니다. 사용자가 직접 메모리를 해제하지 않아도되서 편리하며 메모리누수와 같은 오류를 방지할 수 있습니다.
    
    java는 힙영역에 인스턴스를 저장하고 생성시기에 따라 old영역과 young영역으로 구분하여 보관합니다. 영역마다 관리되는 알고리즘이 다르지만 기본적으로 GC가 전역변수나 스택에 저장된 객체를 마킹하며 더 이상 참조되지 않은 메모리를 삭제 합니다. 그 뒤 메모리의 단편화를 방지하기 위해 메모리 영역을 앞에서 부터 채워나가는 작업을 수행합니다.
    
    메모리가 언제 해제되는지 정확히 알수 없어 제어가 힘들고, GC가 실행될때 GC를 실행하는 스레드 외 다른 모든 스레드는 작업을 중단하됨으로 오버헤드가 발생할수있다는 문제가 있습니다.
    

- 컬렉션 프레임워크에 대해서 설명해주세요.
    
    자바의 컬렉션 프레임워크는 다수의 데이터를 쉽고 효율적을 관리할수있도록 제공하는 자료구조와 알고리즘을 구조화한 클래스를 모아둔 것입니다.
    
    주요 인터페이스는 List와 Set, Map, Queue 인터페이스가 있습니다. 컬렉션 프레임워크를 구성하는 모든 클래스가 제네릭으로 표현되어 다양한 타입을 사용가능합니다. 
    
    - List → 순서가 있는 데이터의 집합으로, 데이터의 중복을 허용한다. (arraylist, linkedlist, vector, stack, queue(deque))
        - *****ArrayList* 를 초기화하는 동안 용량을 지정하면 해당 용량까지 객체를 저장할 수 있는 충분한 메모리가 할당됩니다. 논리적 크기는 0으로 유지됩니다. 용량을 확장할 때가 되면 더 큰 새 어레이가 생성되고 값이 여기에 복사됩니다.
    - Set → 순서가 없는 데이터의 집합, 데이터의 중복을 허용 (hashset, treeset)
    - Map → 키와 값의 한쌍으로 이루어지는 데이터 집합, 순서가 없다. 키는 중복을 허용하지 않고 값은 중복될 수 있다. (hashMap, hashTable)
    

- 제네릭에 대해서 설명해주세요.
    
    제네릭은 변수 타입을 일반화한 매개변수로 클래스나 인터페이스를 작성할때 타입을 명시하지 않고, 나중에 사용할때 지정해 주는 것을 말합니다. 꺽새를 사용하여 표현하고 형변환에 번거로움이 없고 재사용과 유지보수성이 높습니다. 또한 컴파일 시에 객체의 타입을 체크 해주기때문에 타입 안정성이 높습니다.
    
    collection프레임워크를 통해 제네릭 형식을 자주 접할 수 있습니다.
    

- 애노테이션에 대해서 설명해주세요.
    
    어노테이션은 사전적의미로 주석을 뜻하며, 소스코드에 추가하여 사용할 수 있는 메타 데이터의 일종입니다. 어플리케이션이 처리해야할 데이터가 아니라 컴파일 과정과 실행 과정에서 코드를 어떻게 처리하는지 정의해주는 방식입니다. 
    
    java 표준 어노테이션인 @Override (오버라이딩이 올바른지 컴파일러가 체크한다.)
    
    개발자가 직접 작성한 Class에 Bean을 등록하기 위한 어노테이션인 @Component와 @Service, @Repository, @Controller나 bean을 주입하는 @Autowired와 같은 어노테이션이 떠오릅니다..
    

- 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
    
    오버로딩은 같은 클래스 내에 동일한 메소드 이름은 같지만  매개변수의 타입이나 개수를 다르게 구현하는 것을 의미합니다. 
    
    오버라이딩은 상위 클래스의 메소드를 재정의하는 것입니다. 대표적인 예로 객체의 동등성 비교를 위해 Objects 클래스의 `equals` and `hashcode` 재정의하는 것이 있습니다. 
    
    (hashcode → hashcode는 객체의 주소 값을 해싱기법을 이용하여 만든 코드를 의미합니다. 객체의 고유값이며 java의 규칙에 의해 hash 자료구조에 의해 동등성을 비교할때 해시코드가 일치해야 equals를 비교하기때문에 equals를 재정의 할때 함께 재정의 해줍니다.)
