- SOLID(객체 지향 5대 원칙)에 대해 설명해주세요
    - 단일책임 원칙 → 하나의 모듈(하나의 클래스)은 하나의 책임만 가진다. 하나의 로직에 대해 변경이 필요할때 다른 모듈을 건드릴 필요없이 딱 한가지만 수정하면 된다.
    - 개방폐쇄 원칙 → 확장에 열려있고 수정에 닫혀있어야한다. 변하지 않는 부분은 고정하고 변하는 부분은 추상화함하여 변경이 필요할땐 추상화된 부분을 확장하는 방식으로 개방-패쇄의 원칙을 지킬 수 있다.
        
        (컴파일 시점에서는 추상화된 클래스에 의존하지만 런타임 시점에는 구체 클래스에 의존한다.)
        
    - 리스코프 치환 원칙 → 하위 타입은 상위 타입을 대체할 수 있어야한다. 클라이언트 관점에서 부모 클래스와 자식 클래스의 행동이 호환되어한다는 것으로 대체 가능성을 결정하는 것은 해당 객체를 이용하는 클라이언트다. (상속 관계의 특징 정의)
    - 인터페이스 분리 원칙 → 인터페이스를 목적과 용도에 맞게 분리하여아한다. 클라이언트가 관심에 맞는 인터페이스만을 접근하게 하여 불필요한 간섭을 최소하고 변경에 대한 영향을 더욱 세밀하게 제어할 수 있다. (인터페이스를 기능에 맞는 작은 단위로 분리하여 필요한 기능의 인터페이스들만 받아 구현할 수 있다.)
    - 의존관계 역전 원칙 → 고수준의 모듈(추상화된 모듈)은 저수준의 모듈(구현체)에 의존해서는 안되며 저수준의 모듈은 모두 고수준의 모듈에 의존해야한다는 것을 의미한다. (의존관계가 모두 인터페이스를 바라보고 있음으로 의존관계가 역전되었다. - 컴파일 시점 기준)

- 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
    
    동일성은 객체의 주소를 비교하는 것이고 동등성은 객체의 같음을 비교하는 것입니다. 
    
    Java에서는 Object 클래스에 정의된 equal 메소드가 동등성을 비교합니다. 따라서 개발자가 원한다면 equal 메소드를 오버라이딩하여 동등성의 판단기준을 정의해줄 수 있습니다. 
    
    → 오버라이딩 안하면 동일성을 비교하기 때문에 무조건 오버라이딩을 해야하는 것
    
    → hashcode를 먼저 비교한다. 원칙적으로 hash에 관련된 자료구조를 사용하지않으면 오버라이딩해줄 필요없다.
    

- 원시타입과 참조타입의 차이에 대해 설명해주세요.
    
    원시타입은 정수, 실수, 문자 등 실제 데이터를 저장하는 타입으로 Java의 원시타입은 8개(boolean(false), char, byte, short, int, long, float(플롯), double)가 존재하며 나머지는 모두 참조타입니다. 
    
    참조 타입은 모두 Object 클래스이거나 이를 상속하며 항상 값이 존재해야하는 원시타입과 다르게 null 포인터를 가질 수 있습니다. 
    
    → 제네릭과 optional은 참조타입만 가능
    

- String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
    
    Java에서 문자열을 다루는 대표적인 클래스
    
    - String : 가장 큰 차이점은 String은 **불변** 속성을 가집니다. 때문에 문자열을 수정하는 시점에서 새로운 인스턴스가 생성되게 됩니다.(기존의 객체는 GC에 대상이 된다.)  문자열의 수정, 추가가 빈번하게 일어날 경우 힙 메모리가 부족하여 성능에 영향을 미칠 수 있습니다.
    
    StringBuilder, StringBuffer는 가변 타입의 변수이기때문에 append와 delete등을 이용해 동일 객체 내에서 문자열을 변경할 수 있습니다. 둘은 Thread-safe 우뮤에 관해 차이점이 있는데
    
    - String Buffer의 경우 동기화 키워드를 지원하여 멀티스레드 환경에서도 한전하지만 (string도 불변이기때문에 thread-safe)
    - String Builder는 멀티스레드 환경에 적합하지 않지만 단일스레드에서는 buffer보다 성능이 뛰어납니다.

- Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
    
    RuntimeException을 상속받았는지 여부의 차이로, RuntimeException을 상속받은 Unchecked는 명시적인 예외처리를 강제(try/catch, throw)하지 않습니다.
    
    또한 스프링 Transcation 어노테이션은 기본적책에 의해 Unchecked와 Errors를 대상으로 rollback을 처리합니다.
    
    어노테이션 옵션 변경으로 변경이 가능하지만 try-catch문을 사용해 좀 더 구체적인 unchecked exception으로 처리하는 것이 일반적입니다.(예외애 대한 상황과 메세지를 명확하게 전달하는게 좋기때문에) → check exception을 경우 어차피 사용자가 무조건 처리를 해준다고 가정을 해준다 가정하기 때문에 
    
    - checked : IOException, FileNotFoundException,..
    - unchecked : Nullpoint, indexOutOfBound, IllegalAragument,..

- Java8에서 추가된 기능에 대해서 설명해주세요.
    - 인터페이스에 메소드를 구현하는 default method와 static 메소드를 추가할 수 있다. (인터페이스 확장시 호환성 문제를 해결할 수 있다.) + private method
    - 익명함수를 간결하게 표현해주는 표현식 람다표현식 추가. (하나의 메소드만 정의가 가능하기때문에 두개 이상 메소드를 가진 인터페이스는 표현 불가. 병렬처리가 가능)
    - optional : null을 감싸서 NPE를 줄인다. 포장하는데 오버헤드가 있기때문에 null의 가능성이 있는 경우만 사용한다.
    - Stream API 추가. 컬렉션의 저장 요소를 하나씩 참조하여 람디식으로 처리할 수 있도록 해주는 내부 반복자. 코드가 간결해짐
