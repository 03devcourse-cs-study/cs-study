## 기본질문

## SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
SRP(단일책임원칙) : 한 클래스의 하나의 책임만 가져야 합니다. 

클래스가 여러 책임을 갖게 되면 그 클래스는 각 책임마다 변경되는 이유가 발생하기 때문에 클래스가 한 개의 이유로만 변경되려면 클래스는 한 개의 책임만을 가져야한다고 합니다.

OCP(개방-폐쇄 원칙) :  확장에는 열려 있으나 변경에는 닫혀 있어야 한다는 뜻입니다. **유연함**
에 관련된 원칙입니다.

기**능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않는다.란 뜻으로 하나의 변화가 다른 곳에도 연쇄적 변화를 일으키는 것을 방지하기 위해 만들어졌습니다.** 다형성을 활용해야 합니다.

LSP(리스코프 치환 원칙) :  프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하**상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다."**
를 의미합니다. 이를 쉽게 말하면, **특정 메소드가 상위 타입을 인자로 사용한다고 할 때, 그 타입의 하위 타입도 문제 없이 정상적으로 작동을 해야 한다**는 것입니다. 

리스코프 치환 원칙이 지켜지지 않으면 개방 폐쇄 원칙을 위반하게 되므로 기능 확장을 위해 더 많은 부분을 수정해야 합니다. 이것은 확장을 어렵게 하는 것입니다.

ISP(인터페이스 분리 원칙):  클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙입니다. 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 낫습니다. 

즉, 비대한 인터페이스보단 더 작고 구체적인 인터페이스로 분리해야합니다. 

필요 이상으로 많은 걸 포함하는 모듈을 작성하기보다는 각 인터페이스로 분리하는 것이 의존성을 줄일 수 있다.

DIP(의존관계 역전 원칙) :  변화하기 쉬운 구체적인 것에 의존하지 않고, 추상화 의존해야 한다는 뜻입니다.구체적으론 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙입니다. 

객체사이에 서로 도움을 주고받으면 의존 관계가 생깁니다.

구현클래스에 의존하게 되면, 구현클래스의 변화에따라 이를 사용하는 객체의 코드도 바뀔 수 있습니다.

반면에 추상화된 인터페이스를 이용하면 의존성 주입을 이용해서 대상 객체를 변경하지 않고도 의존 객체(인스턴)를 바꿀 수 있게 됩니다.  

리스코프 치환 원칙과 의존 역전 원칙은 개방 폐쇄 원칙을 지원합니다. 

개방 폐쇄 원칙은 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능 확장을 하면서도 기존 코드를 수정하기 않도록 만들어 줍니다. 

여기서, 변화되는 부분을 추상화할 수 있도록 도와주는 원칙이 바로 의존 역전 원칙이고, 다형성을 도와주는 원칙이 리스코프 치환 원칙인 것입니다.
## 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
동일성(==)은 객체의 주소를 비교하는 것이고, 동등성은 객체의 정보가 같음(equals)을 비교하는 것입니다.

기본적으로 자바에서는 Object 클래스에 정의된 equals() 메소드가 동일성 비교를 합니다. 따라서, 개발자는 원한다면 equals() 메소드를 오버라이딩해서 동등성의 판단 기준을 정의해주면 됩니다.

Primitive 타입은 객체가 아닌 값을 비교하므로 == 연산자를 통한 비교시 내용이 같으면 동일하다고 한다.

변수 선언부는 JVM Runtime Data Area의 Stack 영역에 저장되고, 해당 변수에 저장된 상수는 Runtime Constant Pool에 저장된다.JVM Stack의 변수 선언부는 해당 Runtime Constant Pool의 주소값을 가지게 되고 어떠한 변수가 같은 상수를 저장하고 있다면, 이 두 변수는 같은 Runtime Constant Pool의 주소값을 가지기 때문에 엄밀히 말하자면 primitive type 역시 주소값 비교가 이루어지는 것이다.

equals() 메소드를 오버라이딩 할 때는 hashcode()도 같이 오버라이딩 해야 합니다. 해시코드는 객체를 식별하는 정수 값인데, 컬렉션 프레임워크에서 HashSet, HashMap, HashTable은 리턴된 해시코드 값이 같은지를 보고 다르면 다른 객체로 판단하고, 해시 코드값이 같으면 **equals()**메소드로 다시 비교합니다. 해시코드 값이 다른 엔트리끼리는 동등성 비교를 `시도조차 하지 않습니다`
## 원시타입과 참조타입의 차이에 대해 설명해주세요.
원시타입은 Java에서 단 8개 밖에 존재하지 않는 타입입니다. 

나머지는 모두 참조타입이라고 볼 수 있고, Object 클래스이거나 이를 상속하는 클래스들로 이루어져 있습니다.

원시타입은 항상 값이 존재해야 합니다. 반면, Object 타입은 null 포인터를 가질 수 있습니다. 그리고 멤버변수가 초기화될 때, 원시타입은 기본값을 가지지만, 참조타입은 null 포인터를 가지는 차이도 있습니다.

원시 타입은 스택 메모리 영역에 할당되며, 해당 변수에 값이 직접 저장됩니다. 간단한 값에 대한 빠른 접근이 가능하며, 메모리 효율성이 높습니다.

참조 타입은 객체의 참조(주소)를 저장하는 데이터 타입 클래스, 인터페이스, 배열 등이 포함됩니다.

참조 타입은 스택 메모리 영역에 참조(주소)가 할당되며, 실제 객체 데이터는 힙 메모리 영역에 저장됩니다.

Wrapper 클래스가 내부적으로 final primitive 값을 갖는 이유는 불변성(Immutability)을 보장하기 위해서입니다. Java에서 기본 타입(primitive type)은 값 자체를 저장하는 반면, 객체 타입은 값이 저장된 메모리 주소를 저장합니다. Wrapper 클래스는 이러한 객체 타입으로서의 특성을 가지기 때문에, 값의 변경을 막기 위해 불변성을 보장해야 합니다.

제네릭은 원시타입을 사용할 수 없습니다
## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
자바에서 문자열을 다루는 클래스.

String은 불변 입니다.

StringBuilder와 StringBuffer는 이런 String의 불변이라는 특징때문에 문자열을 붙일 수 연산을 지원하는 타입이라고 볼 수 있습니다.

StringBuilder와 StringBuffer는 Thread-safe 여부의 차이가 있습니다. 

StringBuilder는 Thread-safe하지 않습니다. 

따라서 Multi-Thread 환경에서 사용할 때는 StringBuffer를 사용합니다.

**String**           : 문자열 연산이 적고 멀티쓰레드 환경일 경우 사용하는 것이 좋다.

**StringBuilder**  : 문자열 연산이 많고 단일쓰레드이거나 동기화를 고려하지 않아도 되는 경우(메서드 내의 스택도 괜찮다)

**StringBuffer**   : 문자열 연산이 많고 멀티쓰레드 환경일 경우 (다만 동기화때문에 많이 느리다)
## Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
heckedException은 반드시 예외 처리해야하는 예외로 확인된 예외라고도 부를 수 있습니다.

메소드 내에서 try-catch를 하든 throws로 메소드 밖으로 던지든 명시적으로 처리해야 합니다. 

그렇지않으면 컴파일러가 에러를 잡습니다. 

Error와 RunTimeException을 상속받지 않은 Exception들을 모두 포함합니다. 

UncheckedException은 명시적으로 예외처리 해주지 않아도 되는 예외로, 확인되지 않은 예외라고도 부를 수 있습니다. 

주로 예견되지 못하거나 잘못된 입력 값등에 일어나는 예외이며 명시적으로 언체크드예외를 발생시킬수도 있습니다. 

하지만 언체크드 예외도 결국에 처리해주지 않으면 JVM까지 전달되며 처리하지 못하면 default Exception Hanlder가 exception 정보를 노출하며 결국 해당 쓰레드가 중지되며 프로그램이 예기치않게 종료될 수 있습니다. 

둘의 차이는 RuntimeException을 상속하는가의 여부에 따라 다릅니다.

RuntimeException을 상속하면 UncheckedException이 됩니다. 

- 예외 복구 전략이 명확하고 복구가 가능하면 Checked Exception을 try-catch로 `예외 복구`를 하거나, 코드의 흐름을 제어하는 것이 좋다.
- 또한 Checked Exception이 발생했을 경우 이를 Unchecked Exception으로 전환하여 호출한 메서드에서 예외처리를 일일이 선언하지 않아도 되도록 처리할 수 도 있다.
    - 더 구체적인 UnChecked Exception을 발생시키고 예외에 대한 메시지를 명확하게 전달하는 것이 효과적이다.
- 무책임하게 상위 메서드에 throw로 예외를 던지는 행위를 하지 않는 것이 좋다.
    - 상위 메서드들의 책임이 그만큼 증가하기 때문이다.

스프링 트랜잭션 추상화에서 기본 rollback 정책 대상은 바로 RuntimeException을 상속받은 UncheckedException들이며, 개발자가 rollbackFor, unRollbackFor 등과 같은 옵션을 통해 언제든지 바꿀 수 있습니다. 마찬가지로 CheckException도 롤백하도록 바꿀 수 있습니다.
## Java8에서 추가된 기능에 대해서 설명해주세요.
자신이 사용한 경험을 말해주면 더 효과적일 것 같습니다.

Java8에서는 Lambda식, Stream API, Optional, 인터페이스 디폴트 메소드, 날짜 시간 API(LocalDateTime), StringJoiner 등이 추가되었습니다.

lambda는 함수형 프로그래밍을 지원하기 위한 기능이고, 

Stream API는 고차함수를 지원합니다. 

Optional은 Null-safety를 제공하며, Stream과 사용법이 유사합니다. 

날짜 시간 API는 Joda-time등의 라이브러리에서 영향을 받아 괜찮은 API가 되었으며, 

StringJoiner는 문자열을 간단하게 구분자로 합칠 수 있는 기능을 제공합니다.

인터페이스 디폴트 메소드는 인터페이스에 새로운 메서드를 추가하면, 해당 인터페이스를 구현한 모든 클래스에서 새로운 메서드를 구현해야 하는 문제를 해결하기 위해 나오게 되었습니다. 이는 기존에 존재하던 코드와의 호환성 문제를 발생시키고, 인터페이스를 업그레이드하는 데에 제약이 따랐습니다. 때문에 디폴트 메소드를 추가하고 안에 구현을 해놓으면, 해당 인터페이스를 상속받는 클래스들은 구현하지 않아도 되므로 제약사항을 없앨 수 있었습니다.
