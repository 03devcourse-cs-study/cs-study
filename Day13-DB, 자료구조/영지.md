---

- MongoDB에 대해서 간단히 설명해주세요.
    
    document형태의 noSQL입니다. JSON 형태로 (Binary JSON) 데이터베이스를 저장하여 다양한 형태와 구조의 데이터를 저장할 수 있으며 유연한 데이터 모델을 가집니다. 또한 수평적 확장을 지원하여 여러 대의 서버에 데이터를 분산 저장하고 처리할 수 있어 대규모 데이터를 다룰때 적합니다.
    
    key-value형태로 데이터를 보관
    
    읽기 쓰기 모두 뛰어난 성능
    
    Json 형태로 데이터를 보관으로 공간을 효율적으로 사용하지 못함
    
    ***ObjectId*** 타입을 지원하여 데이터는 PK와 같은 고유 id를 가진다. 
    
    → 단점 : 데이터 손실? 
    

- CAP 이론과, Eventual Consistency에 대해서 설명해주세요.****
    
    CAP 이론은 분산 시스템의 일관성(Consistency), 가용성(Availability), 분할 내성(Partition Tolerance) 중에서 최대 2개만 동시에 보장할 수 있다는 이론입니다. 이는 분산 환경에서 모든 요구사항을 동시에 만족하는 완벽한 시스템은 존재하지 않는다는 것을 의미합니다.
    
    - Consitenty(일관성):  모든 노드가 같은 시간에 같은 데이터를 보여줘야 한다는 것입니다. 데이터 변경이 발생하면 모든 복제본이 일관적으로 변경되어야함을 의미(업데이트가 되지 않는 데이터를 조회하는 현상)
    - Availability(가용성): 모든 동작에 대한 응답이 리턴되어야 합니다.
    - Partition Tolerance(분할 내성): 시스템 일부가 네트워크에서 연결이 끊기더라도 전체 시스템이 계속 동작하고 데이터 일관성을 유지할 수 있어야 함을 의미합니다.
    
    Eventual Consistency(결과적 일관성)는 CAP 이론에서 분할 내성을 보장하면서 일관성과 가용성 사이에서 타협하는 개념입니다. 이는 시스템의 모든 노드 간에 변경 사항이 비동기적으로 복제되고 전파되기 때문에, 초기에는 데이터 일관성이 보장되지 않을 수 있지만, 시간이 지나면서 언젠가는 일관성이 보장됨을 의미합니다.
    
    - 배열과 링크드 리스트의 차이를 설명해주세요.
    
    배열는 메모리 상에 데이터가 연속적으로 저장되며 인덱스로 인한 접근이 가능합니다. 인덱스로 접근이 가능하기때문에 O(1)의 시간복잡도를 가지며 처음 생성시 그 크기를 정해줘야한다는 단점이 있습니다.(삽입, 삭제 O(N)) 
    
    링크드 리스트는 식별자가 없으며 메모리상에 데이터가 연속적이 않습니다. 다음 데이터의 위치에 대한 포인터를 가지고 있는 구조이기때문에 조회시 리스트를 타고 탐색해야하기 때문에 O(N)의 시간이 걸리지만 정렬을 하지 않기때문에 삽입, 삭제시 O(1)의 시간복잡도가 걸리며 메모리를 미리 할당하지 않아 낭비하지 않을 수 있습니다.
    

- List와 Set의 차이에 대해서 설명해주세요.
    
    set은 중복을 허용하지 않는 자료구조입니다. List는ㄴ 입력한 순서대로 저장하여 인덱스로 접근할 수 있는 방면 Set은 요소를 순서 없이 저장합니다.
    
    Set은 유일한 값을 확인하기 위해 효율적인 해시 함수나 비교 연산을 사용하므로 일반적으로 검색 및 삽입 속도가 빠릅니다. 
    
    순서가 있는 set → TreeSet
    

- Hash Function, HashTable에 대해서 설명해주세요.
    
    해시 함수(Hash Function)는 임의의 크기를 가진 데이터를 고정된 크기의 값으로 매핑하는 함수입니다. 이 함수는 입력 데이터를 해시 코드(해시 값 또는 해시)로 변환합니다.
    
    해시값의 일관성, 고유성, 고속성 등의 특징으로 효율적인 저장과 검색이 가능하여 다양한 분야에서 사용됩니다. (set, hashTable)
    
    HashTable(해시 테이블)은 해시 함수를 사용하여 데이터를 저장하고 검색하기 위한 자료구조입니다. 데이터의 키(Key)를 해시 함수를 통해 해시 코드(해시 값)로 변환한 후, 해당 해시 코드를 배열의 인덱스로 사용하여 데이터를 저장하고 검색합니다.
    
    해시코드가 배열의 인덱스로 사용되기때문에 상수 시간의 검색이 가능합니다. 그러나 해시 함수의 충돌 가능성이 있기 때문에 동일한 해시 코드를 가진 데이터를 저장할 때 충돌을 처리하기 위한 추가적인 메커니즘이 필요합니다.
    
    - 체이닝 : 같은 해시값을 가지는 입력 값들을 연결 리스트 형태로 연결하여 저장
    - 오픈 어드레싱 : 다른 빈 버킷을 찾아서 데이터를 저장하는 방식
