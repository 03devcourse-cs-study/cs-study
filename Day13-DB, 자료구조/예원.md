# MongoDB에 대해서 설명해주세요

몽고DB는 NoSQL 중 가장 많이 쓰이는 비관계형 데이터베이스 관리 시스템으로  NoSQL DB 종류 가운데 Document DB로써 데이터 객체들이 Document로 저장되는 모델이다.

또한 ACID대신 BASE를 택하여 데이터의 정합성보단 성능과 가용성을 우선시하며, JSON과 유사한 형식인 BSON(Binary JSON)으로 저장합니다 

- ACID vs BASE
    - ACID
        
        ****Atomicity(원자성)****:
        
        트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.
        
        트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.
        
        ****Consistency(일관성)****:
        
        트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
        
        시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.
        
        ****Isolation(독립성,격리성)****:
        
        ****둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
        
        수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
        
        ****Durability(영속성,지속성)****:
        
        성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다.
        
    - BASE
        - ACID와 대조적으로 가용성과 성능을 중시하는 특성을 가진 **분산 시스템의 특성**
            
            **1. 기본적인 가용성 (Basically Avaliable)**
            
            - 부분적인 고장은 있을 수 있으나, 나머지는 사용이 가능하다.주 서버가 안되더라도 백업 서버는 동작한다.
            - 언제든지 사용할 수 있다는 의미를 가지고 있습니다.
            
            **2. 소프트 상태 (Soft State)**
            
            - 외부의 개입이 없어도 정보가 변경될 수 있다는 의미를 가지고 있고 문제가 발생되어 일관성이
            보장되지 않는 경우에는 일관성을 위해 데이터를 자동으로 수정합니다.
            
            **3. 결과적 일관성 (Eventually Consistent)**
            
            - 일시적으로 일관되지 않은 상태가 되어도 일정 시간 후에는 일관적인 상태가 되어야 한다는 의미로 장애 발생 시 일관성을 유지하기 위한 이벤트를 발생시킵니다
    - ACID 모델은 일관된 시스템을 제공
    - BASE 모델은 고가용성을 제공

### 장점

- Schema-less 구조
    - 다양한 형태의 데이터 저장 가능
    - 데이터 모델의 유연한 변화 가능(데이터 모델 변경, 필드 확장 용이)
- Read/Write 성능이 뛰어남
- Scale Out 구조
    - 많은 데이터 저장이 가능
    - 장비 확장이 간단함
- JSON 구조 : 데이터를 직관적으로 이해 가능
- 사용 방법이 쉽고, 개발이 편리함

### **단점**

- 데이터 업데이트 중 장애 발생 시, 데이터 손실 가능
- 많은 인덱스 사용 시, 충분한 메모리 확보 필요
- 데이터 공간 소모가 RDBMS에 비해 많은(비효율적인 Key 중복 입력)
- 복잡한 JOIN 사용시 성능 제약이 따름
- 트랜잭션 지원이 RDBMS 대비 미약함
- 제공되는 MapReduce 작업이 Hadoop에 비해 성능이 떨어짐

### **MongoDB vs MySQL**

- MongoDB와 MySQL에서 동일한 데이터를 가지고 CRUD를 수행할 때, 대부분의 결과가 MongoDB가 빠르게 나옴
- MongoDB의 경우, Single Node와 Multi Node 간에 성능 차이는 거의 없음(Delete 연산을 제외하고 대부분 Multi Node가 근소하게 빠름)
- MongoDB Multi Node의 Insert 연산 중에 연산 실패가 일어나는 경우 발생
- 분산을 목적으로 한 DBMS 선택할 경우, RDBMS에 비해 낮은 비용과 빠른 성능을 제공하는 MongoDB가 유리함

# CAP 이론과, Eventual Consistency에 대해서 설명해주세요.

### CAP이론이란

- CAP 정리에 의하면 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성중에서, 두 가지만 가질 수 있다는 것이다.
- 이 모든 속성을 다 포함한 시스템은 절대로 존재할 수 없다는 것이 CAP 정리이다.
- 위의 그림에서 볼 수 있듯이, Consistency, Availablity를 합치면, `CA` 또는 Consistency와 Partition tolerance를 조합하면 `AP`가 된다.
- 각 특징의 의미
    - 일관성(Consistency) : 데이터를 저장하는 장비가 1대 든 100대든 모든 장비에서 동일한 데이터가 저장되어 있어야 한다는 것이다. `ACID` 원리에서 의미하는 것과 같다. 어떤 데이터베이스 속성에 `C`가 있다면, 트랜잭션 기능 또는 그와 비슷한 매커니즘이 존재한다는 뜻이다.
    - 가용성(Availablity) : 가용성은 죽지 않은 상태의 모든 서버는 클라이언트에게 항상 정상 처리 응답을 보애주어야 한다는 것을 의미한다. 클라이언트가 읽기, 쓰기 요청을 하면 제대로 읽고 쓰는 작업을 해야한다. 현재 시스템에 문제가 있어서 읽을 수 없다고 보내면 가용성이 보장되지 않는 것을 뜻한다.
    - 분단 허용성(Partition tolerance) : 분단 허용성은 클러스터가 여러 대 동작하고 있을 때, 해당 클러스터 사이에 접속이 단절되어 서로 통신을 할 수 없는 상황에서도 시스템이 잘 동작해야 한다는 것이다.
- 관계형 DB와 NoSQL에서는?
    
    **관계형 데이터베이스는 CA 시스템이다. 일관성(C)와 가용성(A)를 보장하되, 분단 허용성(P)는 보장하지 않는다**
    
    > 관계형 데이터베이스가 동시에 다량의 서버를 운용하는 클러스터링에 적합하지 않는 이유가 여기에 있다. 만약 10대의 서버중에서 한 서버의 접속이 끊어졌다고 가정을 하면, 분단 허용성을 지원하지 않으므로 이는 수용할 수 있지만 끊어진 서버 때문에 일관성과 가용성이 훼손되므로 아예 1번 부터 10번까지 모든 서버를 중단시켜서 어떤 클라이언트도 서버와 접속할 수 없어야한다. 일반적으로 불가능한 방법이다.
    > 
    
    > 해결책은 간단한데, CA를 포기하면 된다. CA를 포기한다는 뜻이 극단적으로 일관성과 가용성을 포기하는 것이 아닌 1 ~ 100까지의 수치가 있을 때 일관성과 가용성을 100% 지원하던 것에서 수치를 60%로 낮춘다고 생각을 하면 된다.
    > 
    
    **대부분의 NoSQL 데이터베이스는 CA가 아닌 CP나 AP 시스템이다. 대용량의 분산 시스템을 구축하는데에는 CP보다도 AP가 알맞다. C가 들어가서 강력한 일관성 즉, ACID 트랜잭션을 지원한다고 가정하면 예를 들어 하나의 쓰기 작업을 수행한다고 가정할 때 2대가 정상 응답할 때까지 LOCK이 걸리겠지만 100대라면 너무 긴 시간동안 LOCK이 걸리게 된다.**
    

### Eventual Consistency란

결과적으로 언젠가는 일관성이 보장됨을 의미합니다.

분산 시스템을 구성하려면 CAP 이론에 의해서 일관성과 가용성 중 하나를 포기해야하는 상황이 올 수 있습니다.

클라이언트의 요청을 받았을 때, A서버의 데이터가 변경되면 즉시 다른 서버에 반영되지 않습니다. 아래 두가지 경우가 있습니다.

1. 모든 서버가 동일한 데이터를 갖도록 동기화 하는동안 클라이언트의 접근을 막는 경우 (가용성의 문제)
2. 다른 클라이언트들이 변경된 데이터를 요청했을 때 어떤 클라이언트는 최신의 데이터를, 어떤 클라이언트는 오래된 데이터를 받게되는 경우.(일관성의 문제)

그러나 2번의 경우 **언젠가는 동기화가 되면**, 모든 클라이언트가 동일한 데이터를 받아볼 수 있게 됩니다.

이것이 Eventual Consistency  입니다.

> Eventual consistency는 항목이 새롭게 업데이트되지 않는다는 전제하에 항목의 모든 읽기 작업이 최종적으로는 마지막으로 업데이트된 값을 반환한다는 것을 이론적으로 보장합니다.
> 

### Eventual Consistency 구현 방법

[CAP 이론, RDBMS, NOSQL, Eventual Consistency](https://velog.io/@meme2367/면접-준비-CAP-이론-RDBMS-NOSQL-Eventual-Consistency)

참고: 

[Eventual Consistency 란?](https://velog.io/@soongjamm/Eventual-Consistency-란)

# Hash Function, Hash Table

### HashTable

해시 테이블이란 해시함수를 사용하여 변환한 값을 index로 삼아 키(key)와 데이터(value)를 저장하는 자료구조를 말한다 

해시함수를 사용하여 특정 해시값을 알아내고 그 해시값을 인덱스로 변환하여 키 값과 데이터를 저장하는 자료구조이다. 이는 보통 알고 있는 해시 테이블을 얘기하며 개념자체가 어려운 것은 아니지만 문제가 되는 것은 **충돌(Collision)**이다. 충돌에 대해서 이해하기 위해선 먼저 **적재율(Load Factor)**에 대해서 이해해야 한다.

적재율이란 해시 테이블의 크기 대비, 키의 개수를 말한다. 즉, 키의 개수를 *K*, 해시 테이블의 크기를 *N* 이라고 했을 때 적재율은 *K*/*N* 이다. Direct Address Table은 키 값을 인덱스로 사용하는 구조이기 때문에 적재율이 1 이하이며 적재율이 1 초과인 해시 테이블의 경우는 반드시 충돌이 발생하게 된다.

만약, 충돌이 발생하지 않다고 할 경우 해시 테이블의 탐색, 삽입, 삭제 연산은 모두 *O*(1) 에 수행되지만 충돌이 발생할 경우 탐색과 삭제 연산이 최악에 *O*(*K*) 만큼 걸리게 된다. 이는 같은 인덱스에 모든 키 값과 데이터가 저장된 경우로 충돌이 전부 발생했음을 말한다. 따라서, 충돌을 최대한으로 줄여서 연산속도를 빠르게 하는 것이 해시 테이블의 핵심인데 이에 중요하게 작용하는 것이 바로 해시함수를 구현하는 **해시 알고리즘**이다. 해시 알고리즘이 견고하지 못하게 되면 해시함수로 도출된 값들이 같은 경우가 빈번하게 발생하게 되므로 잦은 충돌로 이어지게 되는 것이다.

결론적으로 해시 테이블의 중점사항은 충돌을 완화하는 것이며 방법으로는 2가지가 있다.

- 체이닝
    - 충돌 시 연결 리스트에 추가하는 방식이다.
- **Open Addressing**
    - 충돌 발생 시 해시함수로 얻은 주소가 아닌 다른 주소 공간에 데이터를 저장한다.

### 해시함수

임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 [함수](https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98)이다.

[https://baeharam.netlify.app/posts/data structure/hash-table](https://baeharam.netlify.app/posts/data%20structure/hash-table)

# 배열과 와 LinkedList의 차이

배열은 메모리상에 순서대로 데이터를 저장합니다. 데이터를 인덱스로 조회할 수 있기 때문에 인덱스 조회성능이 높고, 데이터가 메모리에 순서대로 저장되어 있기 때문에, 비교적 빠르게 탐색을 수행할 수 있습니다.

연결 리스트는 배열과 다르게 순서대로 저장되어 있지 않다. 각각의 데이터가 메모리 공간 상에 고유한 노드로 존재한다. 그리고 이 노드는 자신의 앞에 있는 데이터와 뒤에 있는 데이터에 대한 주소를 기억하고 있다.

링크드 리스트는 배열에 비해 접근 속도가 느리지만 중간에 데이터를 삽입하거나 삭제하는 것이 용이하다는 장점이 있습니다.

- Array는 연속된 메모리 공간에 존재하고 Linked List는 메모리 상에서 떨어져 있는 데이터들이 앞의 데이터와 뒤의 데이터를 기억하는 형태로 존재한다.
- Array에 저장되어 있는 데이터를 조회할 때는 O(1)로 가능하지만 Linked List는 O(N)이 소요된다.
- Array에 데이터 추가 및 삭제할 때는 O(N)이 소요되지만 Linked List는 O(1)로 가능하다.
- 추가적으로 Array는 컴파일 과정에서 메모리가 할당되는 정적 메모리 할당인 반면 Linked List는 런타임 환경에서 메모리가 할당되는 동적 메모리 할당이다.
- 또한 배열은 Stack 영역에 메모리 할당이 되고, Linked List는 Heap 영역에 할당이 된다.

# List와 Set의 차이점

List는 순서가 있는 Collection입니다. List에 데이터를 넣는 순서가 보장되며, 그렇기 때문에 index로 특정 아이템을 가져올 수 있습니다.

Set는 순서를 보장하지 않는 Collection입니다. 그렇기 때문에 index로 특정 아이템을 가져올 수 없습니다.

또한  List는 중복을 허용합니다. 즉, 중복된 아이템을 List에 추가할 수 있습니다.

Set는 중복을 허용하지 않습니다. 즉, 중복된 아이템은 Set에 추가되지 않습니다. 중복된 값을 추가하려고 하면 무시됩니다.

- 언제 list와 set을 사용해야할까?
    - 저장되는 데이터의 순서를 보장해야한다면 List를 사용해야 합니다.
    - contains(element)는 Collection에 데이터가 존재하는지 확인하는 메소드입니다. List의 contains 실행 속도는 O(n)이지만, Set는 O(1)으로 매우 빠릅니다. 탐색이 잦다면 Set를 고려해볼 수 있습니다.
    - 데이터가 많지 않다면 성능보다, 구조가 간단한 List를 고려해볼 수 있습니다.
    - 중복을 허용하지 않는 Collection이 필요하다면 Set를 고려해볼 수 있습니다.

[신입 개발자 기술면접 질문 정리 - 자료구조](https://dev-coco.tistory.com/159)
